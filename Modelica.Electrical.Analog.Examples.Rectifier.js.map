{"version":3,"file":"Modelica.Electrical.Analog.Examples.Rectifier.js","sources":["util/omc_error.c","util/division.c","util/list.c","util/memory_pool.c","util/modelica_string.c","util/read_matlab4.c","util/ringbuffer.c","util/rtclock.c","util/varinfo.c","math-support/bigden.c","math-support/biglag.c","math-support/daux.c","math-support/ddasrt.c","math-support/ddassl.c","math-support/dlamch.c","math-support/dlinpk.c","math-support/dogleg.c","math-support/dpmpar.c","math-support/enorm.c","math-support/hybrj.c","math-support/lsame.c","math-support/nelmead.c","math-support/newuoa.c","math-support/newuob.c","math-support/qform.c","math-support/qrfac.c","math-support/r1mpyq.c","math-support/r1updt.c","math-support/trsapp.c","math-support/update.c","math-support/pivot.c","simulation/solver/dassl.c","simulation/solver/delay.c","simulation/solver/events.c","simulation/solver/model_help.c","simulation/solver/mixedSystem.c","simulation/solver/mixedSearchSolver.c","simulation/solver/kinsolSolver.c","simulation/solver/linearSystem.c","simulation/solver/linearSolverLapack.c","simulation/solver/linearSolverLis.c","simulation/solver/nonlinearSystem.c","simulation/solver/nonlinearSolverHybrd.c","simulation/solver/nonlinearSolverNewton.c","simulation/solver/solver_main.c","simulation/solver/stateset.c","simulation/solver/initialization/initialization.c","simulation/solver/initialization/initialization_data.c","simulation/solver/initialization/method_ipopt.c","simulation/solver/initialization/method_kinsol.c","simulation/solver/initialization/method_newuoa.c","simulation/solver/initialization/method_simplex.c","simulation/solver/initialization/method_nelderMeadEx.c","/home/tshort/emscripten/system/include/libcxx/iosfwd","/home/tshort/emscripten/system/include/libcxx/istream","/home/tshort/emscripten/system/include/libcxx/string","/home/tshort/emscripten/system/include/libcxx/ios","/home/tshort/emscripten/system/include/libcxx/streambuf","simulation/results/read_csv.cpp","/home/tshort/emscripten/system/include/libcxx/fstream","/home/tshort/emscripten/system/include/libcxx/__locale","/home/tshort/emscripten/system/include/libcxx/algorithm","simulation/results/simulation_result.cpp","simulation/results/simulation_result_csv.cpp","simulation/results/simulation_result_mat.cpp","/home/tshort/emscripten/system/include/libcxx/ostream","/home/tshort/emscripten/system/include/libcxx/memory","/home/tshort/emscripten/system/include/libcxx/__tree","/home/tshort/emscripten/system/include/libcxx/map","/home/tshort/emscripten/system/include/libcxx/__functional_base","simulation/results/simulation_result_plt.cpp","simulation/simulation_input_xml.cpp","/home/tshort/emscripten/system/include/libcxx/utility","simulation/simulation_runtime.cpp","/home/tshort/emscripten/system/include/libcxx/iterator","/home/tshort/emscripten/system/include/libcxx/locale","simulation/../linearization/linearize.cpp","/home/tshort/emscripten/system/include/libcxx/sstream","linearization/linearize.cpp","simulation/modelinfo.c","simulation/simulation_info_xml.c","simulation/options.c","s_stop.c","sig_die.c","pow_dd.c","pow_di.c","d_sign.c","i_nint.c","s_cmp.c","s_copy.c","close.c","endfile.c","err.c","fmt.c","fmtlib.c","open.c","sfe.c","util.c","wref.c","wrtfmt.c","wsfe.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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BA;AAAA;;;AAwBA;;;AAAA;;;;;;;;;;;;;;;;;;;;ACXA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AADA;AAEA;;;;;AAFA;AAAA;AAAA;;AACA;AADA;AAEA;;;;;AAFA;AAAA;AAAA;;AACA;AADA;AAEA;;;;;AAFA;AAAA;AAAA;;AACA;AADA;AAEA;;;;;AAFA;AAAA;AAAA;;AACA;AADA;AAEA;;;;;AAFA;AAAA;AAAA;;AACA;AADA;AAEA;;;;;AAFA;AAAA;AAAA;;AACA;AADA;AAEA;;;;;AAFA;AAAA;AAAA;;;AACA;AAIA;;;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AADA;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAA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;;AAOA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAVA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAVA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAVA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AAAA;;;;AACA;AADA;;;AAIA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAnBA;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAGA;AAAA;AACA;AAAA;AAMA;AAAA;AAGA;AAGA;AAXA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;;;;;AADA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AALA;AAOA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AADA;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;;;;;;;;;AAEA;AAAA;AAEA;A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AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAKA;AAAA;AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAMA;AAAA;AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AACA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAGA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AAAA;;AAGA;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAKA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAEA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAKA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAHA;AAAA;AAAA;AAAA;;AAMA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAGA;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AADA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAEA;AACA;AAIA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;;A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AACA;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;;AAJA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AADA;AACA;;;;;AADA;AAAA;AAAA;AAAA;;;;;;;AAEA;AACA;AAAA;AAAA;AACA;;;;;;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACuBA;AAAA;AAEA;AC48BA;AAAA;AAAA;AAAA;AAA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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ8yDA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AD2iCA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AI14BA;AAAA;AhBs3CA;;;;;AY72BA;AD46CA;ACpmDA;AAAA;AD4mDA;AAAA;ACz1CA;AAkBA;AAoRA;AAjYA;AD46CA;ACpmDA;AAAA;AD4mDA;AAAA;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;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAFA;;;AAEA;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;AAFA;AAAA;AAAA;AAAA;;;;;;;;AA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAuBA;AAAA;AACA;AAwFA;;;AAjHA;AAAA;AAAA;AAAA;;;AAA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuKA;;AAvKA;AAAA;AAAA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","sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TYPE_VIS char_traits;\ntemplate<class _Tp>     class _LIBCPP_TYPE_VIS allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TYPE_VIS fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef long long streamoff;        // for char_traits in <string>\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","// -*- C++ -*-\n//===--------------------------- istream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ISTREAM\n#define _LIBCPP_ISTREAM\n\n/*\n    istream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_istream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream(basic_istream&& rhs);\n    virtual ~basic_istream();\n\n    // 27.7.1.1.2 Assign/swap:\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream& operator>>(bool& n);\n    basic_istream& operator>>(short& n);\n    basic_istream& operator>>(unsigned short& n);\n    basic_istream& operator>>(int& n);\n    basic_istream& operator>>(unsigned int& n);\n    basic_istream& operator>>(long& n);\n    basic_istream& operator>>(unsigned long& n);\n    basic_istream& operator>>(long long& n);\n    basic_istream& operator>>(unsigned long long& n);\n    basic_istream& operator>>(float& f);\n    basic_istream& operator>>(double& f);\n    basic_istream& operator>>(long double& f);\n    basic_istream& operator>>(void*& p);\n\n    // 27.7.1.3 Unformatted input:\n    streamsize gcount() const;\n    int_type get();\n    basic_istream& get(char_type& c);\n    basic_istream& get(char_type* s, streamsize n);\n    basic_istream& get(char_type* s, streamsize n, char_type delim);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);\n\n    basic_istream& getline(char_type* s, streamsize n);\n    basic_istream& getline(char_type* s, streamsize n, char_type delim);\n\n    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* s, streamsize n);\n    streamsize readsome(char_type* s, streamsize n);\n\n    basic_istream& putback(char_type c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type);\n    basic_istream& seekg(off_type, ios_base::seekdir);\n};\n\n// 27.7.1.2.3 character extraction templates:\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);\n\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);\n\ntypedef basic_istream<char> istream;\ntypedef basic_istream<wchar_t> wistream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_iostream :\n    public basic_istream<charT,traits>,\n    public basic_ostream<charT,traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);\n    basic_iostream(basic_iostream&& rhs);\n    virtual ~basic_iostream();\n\n    // assign/swap\n    basic_iostream& operator=(basic_iostream&& rhs);\n    void swap(basic_iostream& rhs);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);\n\ntypedef basic_iostream<char> iostream;\ntypedef basic_iostream<wchar_t> wiostream;\n\ntemplate <class charT, class traits>\n  basic_istream<charT,traits>&\n  ws(basic_istream<charT,traits>& is);\n\ntemplate <class charT, class traits, class T>\n  basic_istream<charT, traits>&\n  operator>>(basic_istream<charT, traits>&& is, T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_istream\n    : virtual public basic_ios<_CharT, _Traits>\n{\n    streamsize __gc_;\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_istream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream(basic_istream&& __rhs);\n#endif\n\n    // 27.7.1.1.2 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream& operator=(basic_istream&& __rhs);\n#endif\n    void swap(basic_istream& __rhs);\npublic:\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*__pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);\n    basic_istream& operator>>(bool& __n);\n    basic_istream& operator>>(short& __n);\n    basic_istream& operator>>(unsigned short& __n);\n    basic_istream& operator>>(int& __n);\n    basic_istream& operator>>(unsigned int& __n);\n    basic_istream& operator>>(long& __n);\n    basic_istream& operator>>(unsigned long& __n);\n    basic_istream& operator>>(long long& __n);\n    basic_istream& operator>>(unsigned long long& __n);\n    basic_istream& operator>>(float& __f);\n    basic_istream& operator>>(double& __f);\n    basic_istream& operator>>(long double& __f);\n    basic_istream& operator>>(void*& __p);\n\n    // 27.7.1.3 Unformatted input:\n    _LIBCPP_INLINE_VISIBILITY\n    streamsize gcount() const {return __gc_;}\n    int_type get();\n    basic_istream& get(char_type& __c);\n    basic_istream& get(char_type* __s, streamsize __n);\n    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb);\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);\n\n    basic_istream& getline(char_type* __s, streamsize __n);\n    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);\n\n    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* __s, streamsize __n);\n    streamsize readsome(char_type* __s, streamsize __n);\n\n    basic_istream& putback(char_type __c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type __pos);\n    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_istream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n//    ~sentry() = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,\n                                               bool __noskipws)\n    : __ok_(false)\n{\n    if (__is.good())\n    {\n        if (__is.tie())\n            __is.tie()->flush();\n        if (!__noskipws && (__is.flags() & ios_base::skipws))\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            _Ip __i(__is);\n            _Ip __eof;\n            for (; __i != __eof; ++__i)\n                if (!__ct.is(__ct.space, *__i))\n                    break;\n            if (__i == __eof)\n                __is.setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        __ok_ = __is.good();\n    }\n    else\n        __is.setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>::basic_istream(basic_streambuf<char_type, traits_type>* __sb)\n    : __gc_(0)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)\n    : __gc_(__rhs.__gc_)\n{\n    __rhs.__gc_ = 0;\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::~basic_istream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istream<_CharT, _Traits>::swap(basic_istream& __rhs)\n{\n    _VSTD::swap(__gc_, __rhs.__gc_);\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(float& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(bool& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(void*& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<short>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::min();\n            }\n            else if (__temp > numeric_limits<short>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::max();\n            }\n            else\n                __n = static_cast<short>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<int>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::min();\n            }\n            else if (__temp > numeric_limits<int>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::max();\n            }\n            else\n                __n = static_cast<int>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_istream& (*__pf)(basic_istream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type, traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n-1)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                *__s++ = __ch;\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            *__s = _CharT();\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n            if (_Traits::eq_int_type(__i, _Traits::eof()))\n                __is.setstate(ios_base::eofbit | ios_base::failbit);\n            else\n                __c = _Traits::to_char_type(__i);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    ios_base::iostate __err = ios_base::goodbit;\n                    while (true)\n                    {\n                        typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                        if (traits_type::eq_int_type(__i, _Traits::eof()))\n                        {\n                           __err |= ios_base::eofbit;\n                           break;\n                        }\n                        if (traits_type::eq_int_type(\n                                __sb->sputc(traits_type::to_char_type(__i)),\n                                traits_type::eof()))\n                            break;\n                        ++__gc_;\n                        this->rdbuf()->sbumpc();\n                    }\n                    if (__gc_ == 0)\n                       __err |= ios_base::failbit;\n                    this->setstate(__err);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    if (__gc_ == 0)\n                        this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::get()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            __r = this->rdbuf()->sbumpc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n               this->setstate(ios_base::failbit | ios_base::eofbit);\n            else\n                __gc_ = 1;\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type& __c)\n{\n    int_type __ch = get();\n    if (__ch != traits_type::eof())\n        __c = traits_type::to_char_type(__ch);\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (__n > 0)\n            {\n                ios_base::iostate __err = ios_base::goodbit;\n                while (__gc_ < __n-1)\n                {\n                    int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    *__s++ = __ch;\n                    ++__gc_;\n                     this->rdbuf()->sbumpc();\n                }\n                *__s = char_type();\n                if (__gc_ == 0)\n                   __err |= ios_base::failbit;\n                this->setstate(__err);\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n)\n{\n    return get(__s, __n, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,\n                                    char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))\n                        break;\n                    ++__gc_;\n                    this->rdbuf()->sbumpc();\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb)\n{\n    return get(__sb, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            while (true)\n            {\n                typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                if (traits_type::eq_int_type(__i, traits_type::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                char_type __ch = traits_type::to_char_type(__i);\n                if (traits_type::eq(__ch, __dlm))\n                {\n                    this->rdbuf()->sbumpc();\n                    ++__gc_;\n                    break;\n                }\n                if (__gc_ >= __n-1)\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n                *__s++ = __ch;\n                this->rdbuf()->sbumpc();\n                ++__gc_;\n            }\n            if (__n > 0)\n                *__s = char_type();\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n)\n{\n    return getline(__s, __n, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            if (__n == numeric_limits<streamsize>::max())\n            {\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            else\n            {\n                while (__gc_ < __n)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::peek()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __r = this->rdbuf()->sgetc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n                this->setstate(ios_base::eofbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __gc_ = this->rdbuf()->sgetn(__s, __n);\n            if (__gc_ != __n)\n                this->setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nstreamsize\nbasic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n    streamsize __c = this->rdbuf()->in_avail();\n    switch (__c)\n    {\n    case -1:\n        this->setstate(ios_base::eofbit);\n        break;\n    case 0:\n        break;\n    default:\n        read(__s, _VSTD::min(__c, __n));\n        break;\n    }\n    return __gc_;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::putback(char_type __c)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::unget()\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nint\nbasic_istream<_CharT, _Traits>::sync()\n{\n    int __r = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0)\n                return -1;\n            if (this->rdbuf()->pubsync() == -1)\n            {\n                this->setstate(ios_base::badbit);\n                return -1;\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::pos_type\nbasic_istream<_CharT, _Traits>::tellg()\n{\n    pos_type __r(-1);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(pos_type __pos)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n            this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nws(basic_istream<_CharT, _Traits>& __is)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __is.setstate(ios_base::eofbit);\n                   break;\n                }\n                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))\n                    break;\n                __is.rdbuf()->sbumpc();\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)\n{\n    __is >> __x;\n    return __is;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_iostream\n    : public basic_istream<_CharT, _Traits>,\n      public basic_ostream<_CharT, _Traits>\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_iostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_iostream(basic_iostream&& __rhs);\n#endif\n\n    // assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_iostream& operator=(basic_iostream&& __rhs);\n#endif\n    void swap(basic_iostream& __rhs);\npublic:\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_streambuf<char_type, traits_type>* __sb)\n    : basic_istream<_CharT, _Traits>(__sb)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs))\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>&\nbasic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::~basic_iostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_iostream<_CharT, _Traits>::swap(basic_iostream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            __str.clear();\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = __str.max_size();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max();\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            __str.clear();\n            ios_base::iostate __err = ios_base::goodbit;\n            streamsize __extr = 0;\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                ++__extr;\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (_Traits::eq(__ch, __dlm))\n                    break;\n                __str.push_back(__ch);\n                if (__str.size() == __str.max_size())\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n            }\n            if (__extr == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n    return getline(__is, __str, __dlm);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            basic_string<_CharT, _Traits> __str;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            streamsize __c = 0;\n            ios_base::iostate __err = ios_base::goodbit;\n            _CharT __zero = __ct.widen('0');\n            _CharT __one = __ct.widen('1');\n            while (__c < _Size)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __x = bitset<_Size>(__str);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class basic_istream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class basic_istream<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(class basic_iostream<char>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ISTREAM\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n);\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n);\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n);\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2) const;\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS) || defined(_LIBCPP_DEBUG)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s) {return strlen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memcpy(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemcpy(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n#ifdef _LIBCPP_DEBUG\n    typedef __debug_iter<basic_string, pointer>          iterator;\n    typedef __debug_iter<basic_string, const_pointer>    const_iterator;\n\n    friend class __debug_iter<basic_string, pointer>;\n    friend class __debug_iter<basic_string, const_pointer>;\n#elif defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    union __lx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__lx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\n#ifdef _LIBCPP_DEBUG\n\n    pair<iterator*, const_iterator*> __iterator_list_;\n\n    _LIBCPP_INLINE_VISIBILITY iterator*&       __get_iterator_list(iterator*)       {return __iterator_list_.first;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator*& __get_iterator_list(const_iterator*) {return __iterator_list_.second;}\n\n#endif  // _LIBCPP_DEBUG\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_DEBUG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#else  // _LIBCPP_DEBUG\n    _LIBCPP_INLINE_VISIBILITY iterator       begin()       {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const {return const_iterator(this, data());}\n    _LIBCPP_INLINE_VISIBILITY iterator       end()         {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const   {return const_iterator(this, data() + size());}\n#endif  // _LIBCPP_DEBUG\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n#ifndef _LIBCPP_DEBUG\n_LIBCPP_INLINE_VISIBILITY inline\n#endif\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#ifdef _LIBCPP_DEBUG\n    iterator::__remove_all(this);\n    const_iterator::__remove_all(this);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n#ifndef _LIBCPP_DEBUG\n_LIBCPP_INLINE_VISIBILITY inline\n#endif\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#ifdef _LIBCPP_DEBUG\n                                                                        __pos\n#endif\n                                                                      )\n{\n#ifdef _LIBCPP_DEBUG\n    const_iterator __beg = begin();\n    if (__iterator_list_.first)\n    {\n        for (iterator* __p = __iterator_list_.first; __p;)\n        {\n            if (*__p - __beg > static_cast<difference_type>(__pos))\n            {\n                iterator* __n = __p;\n                __p = __p->__next;\n                __n->__remove_owner();\n            }\n            else\n                __p = __p->__next;\n        }\n    }\n    if (__iterator_list_.second)\n    {\n        for (const_iterator* __p = __iterator_list_.second; __p;)\n        {\n            if (*__p - __beg > static_cast<difference_type>(__pos))\n            {\n                const_iterator* __n = __p;\n                __p = __p->__next;\n                __n->__remove_owner();\n            }\n            else\n                __p = __p->__next;\n        }\n    }\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    __init(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#ifdef _LIBCPP_DEBUG\n    __str.__invalidate_all_iterators();\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__a == __str.__alloc() || !__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    __str.__zero();\n#ifdef _LIBCPP_DEBUG\n    __str.__invalidate_all_iterators();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n    return iterator(__p + __ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - 1;\n#else\n    return __m - 1;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n#ifdef __LIBCPP_DEBUG\n    assert(__pos <= size());\n#endif\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n#ifdef __LIBCPP_DEBUG\n    assert(__pos < size());\n#endif\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(!empty());\n#endif\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n#ifdef _LIBCPP_DEBUG\n    __invalidate_all_iterators();\n    __str.__invalidate_all_iterators();\n#endif  // _LIBCPP_DEBUG\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos > __sz || __sz - __pos < __n)\n        return npos;\n    if (__n == 0)\n        return __pos;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::search(__p + __pos, __p + __sz, __s, __s + __n,\n                                     __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return find(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos >= __sz)\n        return npos;\n    const value_type* __p = data();\n    const value_type* __r = traits_type::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::find_end(__p, __p + __pos, __s, __s + __n,\n                                       __traits_eq<traits_type>());\n    if (__n > 0 && __r == __p + __pos)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return rfind(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return rfind(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__sz)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const value_type* __p = data();\n        for (const value_type* __ps = __p + __pos; __ps != __p;)\n        {\n            if (traits_type::eq(*--__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos >= __sz || __n == 0)\n        return npos;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::find_first_of(__p + __pos, __p + __sz, __s,\n                                            __s + __n, __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find_first_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_first_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    if (__n != 0)\n    {\n        size_type __sz = size();\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const value_type* __p = data();\n        for (const value_type* __ps = __p + __pos; __ps != __p;)\n        {\n            const value_type* __r = traits_type::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return find_last_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_last_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const value_type* __p = data();\n        const value_type* __pe = __p + __sz;\n        for (const value_type* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (traits_type::find(__s, __n, *__ps) == 0)\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return find_first_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_first_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const value_type* __p = data();\n        const value_type* __pe = __p + __sz;\n        for (const value_type* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!traits_type::eq(*__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    for (const value_type* __ps = __p + __pos; __ps != __p;)\n        if (traits_type::find(__s, __n, *--__ps) == 0)\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return find_last_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return find_last_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    for (const value_type* __ps = __p + __pos; __ps != __p;)\n        if (!traits_type::eq(*--__ps, __c))\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n#ifdef _LIBCPP_DEBUG\n    assert(__s != 0);\n#endif\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY inline\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\nint                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\nlong               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\nunsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\nlong long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\nunsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\nfloat       stof (const string& __str, size_t* __idx = 0);\ndouble      stod (const string& __str, size_t* __idx = 0);\nlong double stold(const string& __str, size_t* __idx = 0);\n\nstring to_string(int __val);\nstring to_string(unsigned __val);\nstring to_string(long __val);\nstring to_string(unsigned long __val);\nstring to_string(long long __val);\nstring to_string(unsigned long long __val);\nstring to_string(float __val);\nstring to_string(double __val);\nstring to_string(long double __val);\n\nint                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\nlong               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\nunsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\nlong long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\nunsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\nfloat       stof (const wstring& __str, size_t* __idx = 0);\ndouble      stod (const wstring& __str, size_t* __idx = 0);\nlong double stold(const wstring& __str, size_t* __idx = 0);\n\nwstring to_wstring(int __val);\nwstring to_wstring(unsigned __val);\nwstring to_wstring(long __val);\nwstring to_wstring(unsigned long __val);\nwstring to_wstring(long long __val);\nwstring to_wstring(unsigned long long __val);\nwstring to_wstring(float __val);\nwstring to_wstring(double __val);\nwstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\n// inline // Deviation from N3690.\n//    We believe the inline to be a defect and have submitted an LWG issue.\n//    An LWG issue number has not yet been assigned.\nnamespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class basic_string<wchar_t>)\n\nextern template\n    string\n    operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;\n    typedef typename traits::pos_type pos_type;\n    typedef typename traits::off_type off_type;\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e);\nerror_condition make_error_condition(io_errc e);\nstorage-class-specifier const error_category& iostream_category;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_TYPE_VIS failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    typedef iostate      io_state;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    typedef openmode     open_mode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n    typedef seekdir seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __except);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n    static int      __xindex_;\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category();\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e)\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e)\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return __rdstate_ & eofbit;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return __rdstate_ & (failbit | badbit);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return __rdstate_ & badbit;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __except)\n{\n    __exceptions_ = __except;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __except) {ios_base::exceptions(__except);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* __s, streamsize __n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type __c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type __c);\n    streamsize sputn(const char_type* __s, streamsize __n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n    void gbump(int __n);\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n    void pbump(int __n);\n    void setp(char_type* __pbeg, char_type* __pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)\n{\n    imbue(__loc);\n    locale __r = __loc_;\n    __loc_ = __loc;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::getloc() const\n{\n    return __loc_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)\n{\n    return setbuf(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,\n                                             ios_base::seekdir __way,\n                                             ios_base::openmode __which)\n{\n    return seekoff(__off, __way, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,\n                                             ios_base::openmode __which)\n{\n    return seekpos(__sp, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_streambuf<_CharT, _Traits>::pubsync()\n{\n    return sync();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::in_avail()\n{\n    if (__ninp_ < __einp_)\n        return static_cast<streamsize>(__einp_ - __ninp_);\n    return showmanyc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::snextc()\n{\n    if (sbumpc() == traits_type::eof())\n        return traits_type::eof();\n    return sgetc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sbumpc()\n{\n    if (__ninp_ == __einp_)\n        return uflow();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sgetc()\n{\n    if (__ninp_ == __einp_)\n        return underflow();\n    return traits_type::to_int_type(*__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)\n{\n    return xsgetn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)\n{\n    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n        return pbackfail(traits_type::to_int_type(__c));\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sungetc()\n{\n    if (__binp_ == __ninp_)\n        return pbackfail();\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputc(char_type __c)\n{\n    if (__nout_ == __eout_)\n        return overflow(traits_type::to_int_type(__c));\n    *__nout_++ = __c;\n    return traits_type::to_int_type(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)\n{\n    return xsputn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::gbump(int __n)\n{\n    __ninp_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,\n                                                          char_type* __gend)\n{\n    __binp_ = __gbeg;\n    __ninp_ = __gnext;\n    __einp_ = __gend;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::pbump(int __n)\n{\n    __nout_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)\n{\n    __bout_ = __nout_ = __pbeg;\n    __eout_ = __pend;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    for (;__i < __n; ++__i, ++__s)\n    {\n        if (__ninp_ < __einp_)\n            *__s = *__ninp_++;\n        else if ((__c = uflow()) != __eof)\n            *__s = traits_type::to_char_type(__c);\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    for (; __i < __n; ++__s, ++__i)\n    {\n        if (__nout_ < __eout_)\n            *__nout_++ = *__s;\n        else if (overflow(traits_type::to_int_type(*__s)) == __eof)\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n",null,"// -*- C++ -*-\n//===------------------------- fstream ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FSTREAM\n#define _LIBCPP_FSTREAM\n\n/*\n    fstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_filebuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n    basic_filebuf(basic_filebuf&& rhs);\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n    basic_filebuf& operator=(basic_filebuf&& rhs);\n    void swap(basic_filebuf& rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* s, ios_base::openmode mode);\n    basic_filebuf* open(const string& s, ios_base::openmode mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual streamsize showmanyc();\n    virtual int_type underflow();\n    virtual int_type uflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& loc);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);\n\ntypedef basic_filebuf<char>    filebuf;\ntypedef basic_filebuf<wchar_t> wfilebuf;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ifstream\n    : public basic_istream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);\n    basic_ifstream(basic_ifstream&& rhs);\n\n    basic_ifstream& operator=(basic_ifstream&& rhs);\n    void swap(basic_ifstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in);\n    void open(const string& s, ios_base::openmode mode = ios_base::in);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);\n\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ofstream\n    : public basic_ostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);\n    basic_ofstream(basic_ofstream&& rhs);\n\n    basic_ofstream& operator=(basic_ofstream&& rhs);\n    void swap(basic_ofstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);\n\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\n\ntemplate <class charT, class traits=char_traits<charT> >\nclass basic_fstream\n    : public basic_iostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    basic_fstream(basic_fstream&& rhs);\n\n    basic_fstream& operator=(basic_fstream&& rhs);\n    void swap(basic_fstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);\n\ntypedef basic_fstream<char>    fstream;\ntypedef basic_fstream<wchar_t> wfstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <__locale>\n#include <cstdio>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_filebuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                           char_type;\n    typedef _Traits                          traits_type;\n    typedef typename traits_type::int_type   int_type;\n    typedef typename traits_type::pos_type   pos_type;\n    typedef typename traits_type::off_type   off_type;\n    typedef typename traits_type::state_type state_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf(basic_filebuf&& __rhs);\n#endif\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf& operator=(basic_filebuf&& __rhs);\n#endif\n    void swap(basic_filebuf& __rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* __s, ios_base::openmode __mode);\n    basic_filebuf* open(const string& __s, ios_base::openmode __mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& __loc);\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    FILE* __file_;\n    const codecvt<char_type, char, state_type>* __cv_;\n    state_type __st_;\n    state_type __st_last_;\n    ios_base::openmode __om_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    bool __read_mode();\n    void __write_mode();\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf()\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __file_(0),\n      __cv_(nullptr),\n      __st_(),\n      __st_last_(),\n      __om_(0),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(false)\n{\n    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))\n    {\n        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());\n        __always_noconv_ = __cv_->always_noconv();\n    }\n    setbuf(0, 4096);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)\n    : basic_streambuf<_CharT, _Traits>(__rhs)\n{\n    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)\n    {\n        __extbuf_ = __extbuf_min_;\n        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);\n        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);\n    }\n    else\n    {\n        __extbuf_ = __rhs.__extbuf_;\n        __extbufnext_ = __rhs.__extbufnext_;\n        __extbufend_ = __rhs.__extbufend_;\n    }\n    __ebs_ = __rhs.__ebs_;\n    __intbuf_ = __rhs.__intbuf_;\n    __ibs_ = __rhs.__ibs_;\n    __file_ = __rhs.__file_;\n    __cv_ = __rhs.__cv_;\n    __st_ = __rhs.__st_;\n    __st_last_ = __rhs.__st_last_;\n    __om_ = __rhs.__om_;\n    __cm_ = __rhs.__cm_;\n    __owns_eb_ = __rhs.__owns_eb_;\n    __owns_ib_ = __rhs.__owns_ib_;\n    __always_noconv_ = __rhs.__always_noconv_;\n    if (__rhs.pbase())\n    {\n        if (__rhs.pbase() == __rhs.__intbuf_)\n            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        else\n            this->setp((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        this->pbump(__rhs. pptr() - __rhs.pbase());\n    }\n    else if (__rhs.eback())\n    {\n        if (__rhs.eback() == __rhs.__intbuf_)\n            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),\n                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));\n        else\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),\n                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));\n    }\n    __rhs.__extbuf_ = 0;\n    __rhs.__extbufnext_ = 0;\n    __rhs.__extbufend_ = 0;\n    __rhs.__ebs_ = 0;\n    __rhs.__intbuf_ = 0;\n    __rhs.__ibs_ = 0;\n    __rhs.__file_ = 0;\n    __rhs.__st_ = state_type();\n    __rhs.__st_last_ = state_type();\n    __rhs.__om_ = 0;\n    __rhs.__cm_ = 0;\n    __rhs.__owns_eb_ = false;\n    __rhs.__owns_ib_ = false;\n    __rhs.setg(0, 0, 0);\n    __rhs.setp(0, 0);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>&\nbasic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)\n{\n    close();\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::~basic_filebuf()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        close();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)\n{\n    basic_streambuf<char_type, traits_type>::swap(__rhs);\n    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n    {\n        _VSTD::swap(__extbuf_, __rhs.__extbuf_);\n        _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);\n        _VSTD::swap(__extbufend_, __rhs.__extbufend_);\n    }\n    else\n    {\n        ptrdiff_t __ln = __extbufnext_ - __extbuf_;\n        ptrdiff_t __le = __extbufend_ - __extbuf_;\n        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;\n        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;\n        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n        {\n            __extbuf_ = __rhs.__extbuf_;\n            __rhs.__extbuf_ = __rhs.__extbuf_min_;\n        }\n        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)\n        {\n            __rhs.__extbuf_ = __extbuf_;\n            __extbuf_ = __extbuf_min_;\n        }\n        __extbufnext_ = __extbuf_ + __rn;\n        __extbufend_ = __extbuf_ + __re;\n        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;\n        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;\n    }\n    _VSTD::swap(__ebs_, __rhs.__ebs_);\n    _VSTD::swap(__intbuf_, __rhs.__intbuf_);\n    _VSTD::swap(__ibs_, __rhs.__ibs_);\n    _VSTD::swap(__file_, __rhs.__file_);\n    _VSTD::swap(__cv_, __rhs.__cv_);\n    _VSTD::swap(__st_, __rhs.__st_);\n    _VSTD::swap(__st_last_, __rhs.__st_last_);\n    _VSTD::swap(__om_, __rhs.__om_);\n    _VSTD::swap(__cm_, __rhs.__cm_);\n    _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);\n    _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);\n    _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);\n    if (this->eback() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->gptr() - this->eback();\n        ptrdiff_t __e = this->egptr() - this->eback();\n        this->setg((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __n,\n                   (char_type*)__extbuf_min_ + __e);\n    }\n    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->pptr() - this->pbase();\n        ptrdiff_t __e = this->epptr() - this->pbase();\n        this->setp((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __e);\n        this->pbump(__n);\n    }\n    if (__rhs.eback() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();\n        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();\n        __rhs.setg((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __n,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n    }\n    else if (__rhs.pbase() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();\n        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();\n        __rhs.setp((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n        __rhs.pbump(__n);\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_filebuf<_CharT, _Traits>::is_open() const\n{\n    return __file_ != 0;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n        __rt = this;\n        const char* __mdstr;\n        switch (__mode & ~ios_base::ate)\n        {\n        case ios_base::out:\n        case ios_base::out | ios_base::trunc:\n            __mdstr = \"w\";\n            break;\n        case ios_base::out | ios_base::app:\n        case ios_base::app:\n            __mdstr = \"a\";\n            break;\n        case ios_base::in:\n            __mdstr = \"r\";\n            break;\n        case ios_base::in | ios_base::out:\n            __mdstr = \"r+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc:\n            __mdstr = \"w+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app:\n        case ios_base::in | ios_base::app:\n            __mdstr = \"a+\";\n            break;\n        case ios_base::out | ios_base::binary:\n        case ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"wb\";\n            break;\n        case ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::app | ios_base::binary:\n            __mdstr = \"ab\";\n            break;\n        case ios_base::in | ios_base::binary:\n            __mdstr = \"rb\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::binary:\n            __mdstr = \"r+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"w+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::in | ios_base::app | ios_base::binary:\n            __mdstr = \"a+b\";\n            break;\n        default:\n            __rt = 0;\n            break;\n        }\n        if (__rt)\n        {\n            __file_ = fopen(__s, __mdstr);\n            if (__file_)\n            {\n                __om_ = __mode;\n                if (__mode & ios_base::ate)\n                {\n                    if (fseek(__file_, 0, SEEK_END))\n                    {\n                        fclose(__file_);\n                        __file_ = 0;\n                        __rt = 0;\n                    }\n                }\n            }\n            else\n                __rt = 0;\n        }\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    return open(__s.c_str(), __mode);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::close()\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_)\n    {\n        __rt = this;\n        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);\n        if (sync())\n            __rt = 0;\n        if (fclose(__h.release()) == 0)\n            __file_ = 0;\n        else\n            __rt = 0;\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::underflow()\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = traits_type::to_int_type(*this->gptr());\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),\n                                 static_cast<size_t>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            __st_last_ = __st_;\n            size_t __nr = fread((void*)__extbufnext_, 1, __nmemb, __file_);\n            if (__nr != 0)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->eback() + __ibs_, __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n            }\n        }\n    }\n    else\n        __c = traits_type::to_int_type(*this->gptr());\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)\n{\n    if (__file_ && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if ((__om_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::overflow(int_type __c)\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    int __width = __cv_->encoding();\n    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    int __whence;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __whence = SEEK_SET;\n        break;\n    case ios_base::cur:\n        __whence = SEEK_CUR;\n        break;\n    case ios_base::end:\n        __whence = SEEK_END;\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n#if _WIN32\n    if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftell(__file_);\n#else\n    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftello(__file_);\n#endif\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)\n{\n    if (__file_ == 0 || sync())\n        return pos_type(off_type(-1));\n#if _WIN32\n    if (fseek(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#else\n    if (fseeko(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#endif\n    __st_ = __sp.state();\n    return __sp;\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_filebuf<_CharT, _Traits>::sync()\n{\n    if (__file_ == 0)\n        return 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (fflush(__file_))\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        state_type __state = __st_last_;\n        bool __update_st = false;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    const int __off =  __cv_->length(__state, __extbuf_,\n                                                     __extbufnext_,\n                                                     this->gptr() - this->eback());\n                    __c += __extbufnext_ - __extbuf_ - __off;\n                    __update_st = true;\n                }\n            }\n        }\n#if _WIN32\n        if (fseek(__file_, -__c, SEEK_CUR))\n            return -1;\n#else\n        if (fseeko(__file_, -__c, SEEK_CUR))\n            return -1;\n#endif\n        if (__update_st)\n            __st_ = __state;\n        __extbufnext_ = __extbufend_ = __extbuf_;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    sync();\n    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);\n    bool __old_anc = __always_noconv_;\n    __always_noconv_ = __cv_->always_noconv();\n    if (__old_anc != __always_noconv_)\n    {\n        this->setg(0, 0, 0);\n        this->setp(0, 0);\n        // invariant, char_type is char, else we couldn't get here\n        if (__always_noconv_)  // need to dump __intbuf_\n        {\n            if (__owns_eb_)\n                delete [] __extbuf_;\n            __owns_eb_ = __owns_ib_;\n            __ebs_ = __ibs_;\n            __extbuf_ = (char*)__intbuf_;\n            __ibs_ = 0;\n            __intbuf_ = 0;\n            __owns_ib_ = false;\n        }\n        else  // need to obtain an __intbuf_.\n        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_\n            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = (char_type*)__extbuf_;\n                __owns_ib_ = false;\n                __extbuf_ = new char[__ebs_];\n                __owns_eb_ = true;\n            }\n            else\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = new char_type[__ibs_];\n                __owns_ib_ = true;\n            }\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbool\nbasic_filebuf<_CharT, _Traits>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\n// basic_ifstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_ifstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);\n    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ifstream(basic_ifstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ifstream& operator=(basic_ifstream&& __rhs);\n#endif\n    void swap(basic_ifstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream()\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)\n    : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>&\nbasic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_ifstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_ifstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ifstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_ofstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_ofstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);\n    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ofstream(basic_ofstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ofstream& operator=(basic_ofstream&& __rhs);\n#endif\n    void swap(basic_ofstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::out);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream()\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)\n    : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>&\nbasic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_ofstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_ofstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ofstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_fstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_fstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_fstream(basic_fstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_fstream& operator=(basic_fstream&& __rhs);\n#endif\n    void swap(basic_fstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream()\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)\n    : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>&\nbasic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_fstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_fstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_fstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FSTREAM\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#ifdef _LIBCPP_MSVCRT\n# include <support/win32/locale_win32.h>\n#elif (defined(__GLIBC__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__sun__)) || defined(__EMSCRIPTEN__)\n# include <xlocale.h>\n#endif  // _WIN32 || __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!_VSTD::has_facet<_Facet>(__other))\n        throw runtime_error(\"locale::combine: locale missing facet\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#ifdef __GLIBC__\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_WIN32)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n#ifdef __APPLE__\n    typedef __uint32_t mask;\n#elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n#elif defined(__EMSCRIPTEN__) ||  defined(__NetBSD__)\n    typedef unsigned short mask;\n#endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#else  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__ || __EMSCRIPTEN__ || __sun__\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? __tab_[static_cast<int>(__c)] & __m : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TYPE_VIS codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TYPE_VIS codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE(class codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE(class codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE(class codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class charT> class _LIBCPP_TYPE_VIS numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator& rand);\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b);\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility>\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG2\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG2\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _VSTD::move(__f);\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_first_of(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return __first1;  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return __first1;\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_RandomAccessIterator1\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __first1;\n    _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return __last1;\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return __first1;\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return __first1;\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __n, __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            swap(*__first, *__last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    pair<const _Tp*, const _Tp*> __p =\n                                   _VSTD::minmax_element(__t.begin(), __t.end());\n    return pair<_Tp, _Tp>(*__p.first, *__p.second);\n}\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    pair<const _Tp*, const _Tp*> __p =\n                           _VSTD::minmax_element(__t.begin(), __t.end(), __comp);\n    return pair<_Tp, _Tp>(*__p.first, *__p.second);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass __rs_default;\n\n__rs_default __rs_get();\n\nclass __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend __rs_default __rs_get();\n};\n\n__rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __merge<_Compare>(move_iterator<value_type*>(__buff),\n                          move_iterator<value_type*>(__p),\n                          move_iterator<_BidirectionalIterator>(__middle),\n                          move_iterator<_BidirectionalIterator>(__last),\n                          __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),\n                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),\n                _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n        {\n            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);\n            return;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _Tp>\nstruct __inplace_merge_switch\n{\n    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__push_heap_front(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,\n                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        difference_type __p = 0;\n        _RandomAccessIterator __pp = __first;\n        difference_type __c = 2;\n        _RandomAccessIterator __cp = __first + __c;\n        if (__c == __len || __comp(*__cp, *(__cp - 1)))\n        {\n            --__c;\n            --__cp;\n        }\n        if (__comp(*__pp, *__cp))\n        {\n            value_type __t(_VSTD::move(*__pp));\n            do\n            {\n                *__pp = _VSTD::move(*__cp);\n                __pp = __cp;\n                __p = __c;\n                __c = (__p + 1) * 2;\n                if (__c > __len)\n                    break;\n                __cp = __first + __c;\n                if (__c == __len || __comp(*__cp, *(__cp - 1)))\n                {\n                    --__c;\n                    --__cp;\n                }\n            } while (__comp(__t, *__cp));\n            *__pp = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__push_heap_back(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n                 typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __push_heap_back<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __push_heap_back<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __push_heap_front<_Compare>(__first, __last, __comp, __len-1);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        __last = __first;\n        ++__last;\n        for (difference_type __i = 1; __i < __n;)\n            __push_heap_back<_Compare>(__first, ++__last, __comp, ++__i);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __push_heap_front<_Compare>(__first, __middle, __comp, __len);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = 0;\n        for (; __first != __last && __r != __result_last; ++__first, ++__r, ++__len)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __push_heap_front<_Compare>(__result_first, __r, __comp, __len);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG2\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG2\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_left(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_right(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n",null,null,null,"// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    void swap(basic_ostream& __rhs);\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&));\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type __pos);\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)\n{\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type,traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 (char*)&__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (char*)&__c + 1 :\n                                     (char*)&__c,\n                                 (char*)&__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 (char*)&__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (char*)&__c + 1 :\n                                     (char*)&__c,\n                                 (char*)&__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = _Traits::length(__str);\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length(__str);\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length((const char*)__str);\n            if (__pad_and_output(_Ip(__os),\n                                 (const char*)__str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (const char*)__str + __len :\n                                     (const char*)__str,\n                                 (const char*)__str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length((const char*)__str);\n            if (__pad_and_output(_Ip(__os),\n                                 (const char*)__str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (const char*)__str + __len :\n                                     (const char*)__str,\n                                 (const char*)__str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    if (!this->fail())\n        this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = __str.size();\n            if (__pad_and_output(_Ip(__os),\n                                 __str.data(),\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str.data() + __len :\n                                     __str.data(),\n                                 __str.data() + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a);\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b);\n    template<class U> bool owner_before(weak_ptr<U> const& b);\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two test(...);\n    template <class _Up> static char test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a)\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_scalar<_Ptr1>::value &&\n                                         !is_pointer<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, true>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY void reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS weak_ptr;\n\nclass __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        explicit shared_ptr(_Yp* __p);\n    template<class _Yp, class _Dp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a);\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp>&& __r);\n#else\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp> __r);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             > shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r)\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r)\n#endif\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic)\n\nclass __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\nvoid declare_reachable(void* __p);\nvoid declare_no_pointers(char* __p, size_t __n);\nvoid undeclare_no_pointers(char* __p, size_t __n);\npointer_safety get_pointer_safety() _NOEXCEPT;\nvoid* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\nvoid* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS __tree_const_iterator;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS multimap;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS set;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS multiset;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Allocator> class __map_node_destructor;\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(false)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_end_node\n             <\n                typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__tree_node_base<_VoidPtr> >\n#else\n                     rebind<__tree_node_base<_VoidPtr> >::other\n#endif\n             >\n{\n    __tree_node_base(const __tree_node_base&);\n    __tree_node_base& operator=(const __tree_node_base&);\npublic:\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__tree_node_base>\n#else\n            rebind<__tree_node_base>::other\n#endif\n                                                pointer;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const __tree_node_base>\n#else\n            rebind<const __tree_node_base>::other\n#endif\n                                                const_pointer;\n    typedef __tree_end_node<pointer> base;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_node_base() _NOEXCEPT\n        : __right_(), __parent_(), __is_black_(false) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef __tree_node_base<_VoidPtr> base;\n    typedef _Tp value_type;\n\n    value_type __value_;\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tree_node(_Args&& ...__args)\n            : __value_(_VSTD::forward<_Args>(__args)...) {}\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node(const value_type& __v)\n            : __value_(__v) {}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n};\n\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS __map_const_iterator;\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS __tree_iterator\n{\n    typedef _NodePtr                                              __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename __node_base::pointer                         __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag iterator_category;\n    typedef _Tp                        value_type;\n    typedef _DiffType                  difference_type;\n    typedef value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS multiset;\n};\n\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS __tree_const_iterator\n{\n    typedef _ConstNodePtr                                         __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node_base>\n#else\n            rebind<__node_base>::other\n#endif\n                                                                  __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef _DiffType                        difference_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() {}\nprivate:\n    typedef typename remove_const<__node>::type  __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                 __non_const_node_pointer;\n    typedef __tree_iterator<value_type, __non_const_node_pointer, difference_type>\n                                                 __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef typename __alloc_traits::void_pointer  __void_pointer;\n\n    typedef __tree_node<value_type, __void_pointer> __node;\n    typedef __tree_node_base<__void_pointer>        __node_base;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef typename __node_base::pointer            __node_base_pointer;\n    typedef typename __node_base::pointer            __node_base_const_pointer;\nprivate:\n    typedef typename __node_base::base __end_node_t;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_ptr;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_const_ptr;\n\n    __node_pointer                                          __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>\n               (\n                   pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_const_pointer>\n               (\n                   pointer_traits<__end_node_const_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first()))\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() _NOEXCEPT\n        {return static_cast<__node_pointer>      (__end_node()->__left_);}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_const_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value));\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        pair<iterator, bool>\n        __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n        iterator\n        __emplace_hint_unique(const_iterator __p, _Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Vp>\n        pair<iterator, bool> __insert_unique(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_unique(const_iterator __p, _Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(const_iterator __p, _Vp&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    pair<iterator, bool> __insert_unique(const value_type& __v);\n    iterator __insert_unique(const_iterator __p, const value_type& __v);\n    iterator __insert_multi(const value_type& __v);\n    iterator __insert_multi(const_iterator __p, const value_type& __v);\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const value_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        __node_holder __construct_node(const value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _VSTD::move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _VSTD::addressof(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n    _NOEXCEPT_(\n        __is_nothrow_swappable<value_compare>::value &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value))\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_alloc(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const value_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    iterator __r = __node_insert_unique(__p, __h.get());\n    if (__r.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _VSTD::move(__h);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __node_traits::destroy(__na, const_cast<value_type*>(_VSTD::addressof(*__p)));\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_const_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value\n#if __has_feature(is_final)\n                                                        && !__is_final(_Compare)\n#endif\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n};\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS __map_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS __map_const_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(\n            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)\n                _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n#if __cplusplus >= 201103L\n    union __value_type\n    {\n        typedef typename map::value_type value_type;\n        typedef typename map::__nc_value_type __nc_value_type;\n        value_type __cc;\n        __nc_value_type __nc;\n\n        template <class ..._Args>\n        __value_type(_Args&& ...__args)\n            : __cc(std::forward<_Args>(__args)...) {}\n\n        __value_type(const __value_type& __v)\n            : __cc(std::move(__v.__cc)) {}\n\n        __value_type(__value_type&& __v)\n            : __nc(std::move(__v.__nc)) {}\n\n        __value_type& operator=(const __value_type& __v)\n            {__nc = __v.__cc; return *this;}\n\n        __value_type& operator=(__value_type&& __v)\n            {__nc = std::move(__v.__nc); return *this;}\n\n        ~__value_type() {__cc.~value_type();}\n    };\n#else\n    struct __value_type\n    {\n        typedef typename map::value_type value_type;\n        value_type __cc;\n\n        __value_type() {}\n\n        template <class _A0>\n        __value_type(const _A0& __a0)\n            : __cc(__a0) {}\n\n        template <class _A0, class _A1>\n        __value_type(const _A0& __a0, const _A1& __a1)\n            : __cc(__a0, __a1) {}\n    };\n#endif\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp = key_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            __tree_.clear();\n            __tree_.value_comp() = __m.__tree_.value_comp();\n            __tree_.__copy_assign_alloc(__m.__tree_);\n            insert(__m.begin(), __m.end());\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        pair<iterator, bool>\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif\n    __node_holder __construct_node_with_key(const key_type& __k);\n\n    __node_base_pointer&\n        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);\n    __node_base_const_pointer\n        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;\n};\n\n// Find place to insert if __k doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k)\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_const_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_const_pointer __parent;\n    __node_base_const_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_const_pointer>(__child)->__value_.__cc.second;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\npair<typename map<_Key, _Tp, _Compare, _Allocator>::iterator, bool>\nmap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __tree_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::iterator\nmap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                   _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_unique(__p.__i_, __h.get());\n    if (__r.__i_.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n#if __cplusplus >= 201103L\n    union __value_type\n    {\n        typedef typename multimap::value_type value_type;\n        typedef typename multimap::__nc_value_type __nc_value_type;\n        value_type __cc;\n        __nc_value_type __nc;\n\n        template <class ..._Args>\n        __value_type(_Args&& ...__args)\n            : __cc(std::forward<_Args>(__args)...) {}\n\n        __value_type(const __value_type& __v)\n            : __cc(std::move(__v.__cc)) {}\n\n        __value_type(__value_type&& __v)\n            : __nc(std::move(__v.__nc)) {}\n\n        __value_type& operator=(const __value_type& __v)\n            {__nc = __v.__cc; return *this;}\n\n        __value_type& operator=(__value_type&& __v)\n            {__nc = std::move(__v.__nc); return *this;}\n\n        ~__value_type() {__cc.~value_type();}\n    };\n#else\n    struct __value_type\n    {\n        typedef typename multimap::value_type value_type;\n        value_type __cc;\n\n        __value_type() {}\n\n        template <class _A0>\n        __value_type(const _A0& __a0)\n            : __cc(__a0) {}\n\n        template <class _A0, class _A1>\n        __value_type(const _A0& __a0, const _A1& __a1)\n            : __cc(__a0, __a1) {}\n    };\n#endif\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                                    __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp = key_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            __tree_.clear();\n            __tree_.value_comp() = __m.__tree_.value_comp();\n            __tree_.__copy_assign_alloc(__m.__tree_);\n            insert(__m.begin(), __m.end());\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        iterator\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                        _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS less<void>\n{\n    template <class _T1, class _T2> _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n};\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT : __f_(&__f) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct ____is_reference_wrapper : public false_type {};\ntemplate <class _Tp> struct ____is_reference_wrapper<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public ____is_reference_wrapper<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n",null,null,"// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<std::pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, std::pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, std::pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, std::pair<T1, T2> >::type&\n    get(std::pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, std::pair<T1, T2> >::type&\n    get(const std::pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, std::pair<T1, T2> >::type&&\n    get(std::pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(std::pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(std::pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(std::pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS reference_wrapper;\n\ntemplate <class _Tp>\nstruct ___make_pair_return\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct ___make_pair_return<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename ___make_pair_return<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY inline\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\n_LIBCPP_INLINE_VISIBILITY inline\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n",null,"// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#ifdef _LIBCPP_DEBUG2\n#   include <__debug>\n#else\n#   define _LIBCPP_ASSERT(x, m) ((void)0)\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct ____iterator_traits {};\n\ntemplate <class _Iter>\nstruct ____iterator_traits<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  ____iterator_traits\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {__t = current; return *--__t;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(&__x) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(&__x) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(&__x), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(const _Iter& __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\n#ifdef _LIBCPP_DEBUG\n\n// __debug_iter\n\ntemplate <class _Container, class _Iter> class __debug_iter;\n\ntemplate <class _Container, class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);\n\ntemplate <class _Container, class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);\n\ntemplate <class _Container, class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);\n\ntemplate <class _Container, class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);\n\ntemplate <class _Container, class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);\n\ntemplate <class _Container, class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);\n\ntemplate <class _Container, class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __debug_iter<_Container, _Iter1>::difference_type\noperator-(const __debug_iter<_Container, _Iter1>&, const __debug_iter<_Container, _Iter2>&);\n\ntemplate <class _Container, class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__debug_iter<_Container, _Iter>\noperator+(typename __debug_iter<_Container, _Iter>::difference_type, const __debug_iter<_Container, _Iter>&);\n\ntemplate <class _Container, class _Iter>\nclass __debug_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef _Container                                                 __container_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\n    __debug_iter* __next;\n    __container_type* __cont;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __debug_iter() : __next(0), __cont(0) {}\n    _LIBCPP_INLINE_VISIBILITY __debug_iter(const __debug_iter& __x)\n        : __i(__x.base()), __next(0), __cont(0) {__set_owner(__x.__cont);}\n    __debug_iter& operator=(const __debug_iter& __x);\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __debug_iter(const __debug_iter<_Container, _Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0)\n        : __i(__u.base()), __next(0), __cont(0) {__set_owner(__u.__cont);}\n    _LIBCPP_INLINE_VISIBILITY ~__debug_iter() {__remove_owner();}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {assert(__is_deref()); return *__i;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY __debug_iter& operator++() {assert(__can_increment()); ++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY __debug_iter  operator++(int)\n        {__debug_iter __tmp(*this); operator++(); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __debug_iter& operator--() {assert(__can_decrement()); --__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY __debug_iter  operator--(int)\n        {__debug_iter __tmp(*this); operator--(); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __debug_iter  operator+ (difference_type __n) const\n        {__debug_iter __t(*this); __t += __n; return __t;}\n    __debug_iter& operator+=(difference_type __n);\n    _LIBCPP_INLINE_VISIBILITY __debug_iter  operator- (difference_type __n) const\n        {__debug_iter __t(*this); __t -= __n; return __t;}\n    _LIBCPP_INLINE_VISIBILITY __debug_iter& operator-=(difference_type __n)\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const\n        {return *(*this + __n);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY __debug_iter(const __container_type* __c, iterator_type __x)\n        : __i(__x), __next(0), __cont(0) {__set_owner(__c);}\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const {return __i;}\n\n    void __set_owner(const __container_type* __c);\n    void __remove_owner();\n    static void __remove_all(__container_type* __c);\n    static void swap(__container_type* __x, __container_type* __y);\n\n    _LIBCPP_INLINE_VISIBILITY bool __is_deref() const\n        {return __is_deref(__is_random_access_iterator<iterator_type>());}\n    bool __is_deref(false_type) const;\n    bool __is_deref(true_type) const;\n    _LIBCPP_INLINE_VISIBILITY bool __can_decrement() const\n        {return __can_decrement(integral_constant<int, is_pointer<iterator_type>::value ? 2:\n                                                       __is_random_access_iterator<iterator_type>::value ? 1 : 0>());}\n    bool __can_decrement(integral_constant<int, 0>) const;\n    bool __can_decrement(integral_constant<int, 1>) const;\n    bool __can_decrement(integral_constant<int, 2>) const;\n    _LIBCPP_INLINE_VISIBILITY bool __can_increment() const\n        {return __can_increment(integral_constant<int, is_pointer<iterator_type>::value ? 2:\n                                                       __is_random_access_iterator<iterator_type>::value ? 1 : 0>());}\n    bool __can_increment(integral_constant<int, 0>) const;\n    bool __can_increment(integral_constant<int, 1>) const;\n    bool __can_increment(integral_constant<int, 2>) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __can_add(difference_type __n) const\n        {return __can_add(__n, is_pointer<iterator_type>());}\n    bool __can_add(difference_type __n, false_type) const;\n    bool __can_add(difference_type __n, true_type) const;\n\n    template <class _Cp, class _Up> friend class __debug_iter;\n    friend class _Container::__self;\n\n    template <class _Cp, class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);\n\n    template <class _Cp, class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);\n\n    template <class _Cp, class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);\n\n    template <class _Cp, class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);\n\n    template <class _Cp, class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);\n\n    template <class _Cp, class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);\n\n    template <class _Cp, class _Iter1, class _Iter2>\n    friend\n    typename __debug_iter<_Cp, _Iter1>::difference_type\n    operator-(const __debug_iter<_Cp, _Iter1>&, const __debug_iter<_Cp, _Iter2>&);\n\n    template <class _Cp, class _Iter1>\n    friend\n    __debug_iter<_Cp, _Iter1>\n    operator+(typename __debug_iter<_Cp, _Iter1>::difference_type, const __debug_iter<_Cp, _Iter1>&);\n};\n\ntemplate <class _Container, class _Iter>\n__debug_iter<_Container, _Iter>&\n__debug_iter<_Container, _Iter>::operator=(const __debug_iter& __x)\n{\n    if (this != &__x)\n    {\n        __remove_owner();\n        __i = __x.__i;\n        __set_owner(__x.__cont);\n    }\n    return *this;\n}\n\ntemplate <class _Container, class _Iter>\nvoid\n__debug_iter<_Container, _Iter>::__set_owner(const __container_type* __c)\n{\n    __cont = const_cast<__container_type*>(__c);\n    __debug_iter*& __head = __cont->__get_iterator_list(this);\n    __next = __head;\n    __head = this;\n}\n\ntemplate <class _Container, class _Iter>\nvoid\n__debug_iter<_Container, _Iter>::__remove_owner()\n{\n    if (__cont)\n    {\n        __debug_iter*& __head = __cont->__get_iterator_list(this);\n        if (__head == this)\n            __head = __next;\n        else\n        {\n            __debug_iter* __prev = __head;\n            for (__debug_iter* __p = __head->__next; __p != this; __p = __p->__next)\n                __prev = __p;\n            __prev->__next = __next;\n        }\n        __cont = 0;\n    }\n}\n\ntemplate <class _Container, class _Iter>\nvoid\n__debug_iter<_Container, _Iter>::__remove_all(__container_type* __c)\n{\n    __debug_iter*& __head = __c->__get_iterator_list((__debug_iter*)0);\n    __debug_iter* __p = __head;\n    __head = 0;\n    while (__p)\n    {\n        __p->__cont = 0;\n        __debug_iter* __n = __p->__next;\n        __p->__next = 0;\n        __p = __n;\n    }\n}\n\ntemplate <class _Container, class _Iter>\nvoid\n__debug_iter<_Container, _Iter>::swap(__container_type* __x, __container_type* __y)\n{\n    __debug_iter*& __head_x = __x->__get_iterator_list((__debug_iter*)0);\n    __debug_iter*& __head_y = __y->__get_iterator_list((__debug_iter*)0);\n    __debug_iter* __p = __head_x;\n    __head_x = __head_y;\n    __head_y = __p;\n    for (__p = __head_x; __p; __p = __p->__next)\n        __p->__cont = __x;\n    for (__p = __head_y; __p; __p = __p->__next)\n        __p->__cont = __y;\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__is_deref(false_type) const\n{\n    if (__cont == 0)\n        return false;\n    return __i != __cont->end().base();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__is_deref(true_type) const\n{\n    if (__cont == 0)\n        return false;\n    return __i < __cont->end().base();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_decrement(integral_constant<int, 0>) const\n{\n    if (__cont == 0)\n        return false;\n    return __i != __cont->begin().base();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_decrement(integral_constant<int, 1>) const\n{\n    if (__cont == 0)\n        return false;\n    iterator_type __b = __cont->begin().base();\n    return __b < __i && __i <= __b + __cont->size();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_decrement(integral_constant<int, 2>) const\n{\n    if (__cont == 0)\n        return false;\n    iterator_type __b = __cont->begin().base();\n    return __b < __i && __i <= __b + __cont->size();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_increment(integral_constant<int, 0>) const\n{\n    if (__cont == 0)\n        return false;\n    return __i != __cont->end().base();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_increment(integral_constant<int, 1>) const\n{\n    if (__cont == 0)\n        return false;\n    iterator_type __b = __cont->begin().base();\n    return __b <= __i && __i < __b + __cont->size();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_increment(integral_constant<int, 2>) const\n{\n    if (__cont == 0)\n        return false;\n    iterator_type __b = __cont->begin().base();\n    return __b <= __i && __i < __b + __cont->size();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_add(difference_type __n, false_type) const\n{\n    if (__cont == 0)\n        return false;\n    iterator_type __b = __cont->begin().base();\n    iterator_type __j = __i + __n;\n    return __b <= __j && __j <= __b + __cont->size();\n}\n\ntemplate <class _Container, class _Iter>\nbool\n__debug_iter<_Container, _Iter>::__can_add(difference_type __n, true_type) const\n{\n    if (__cont == 0)\n        return false;\n    iterator_type __b = __cont->begin().base();\n    iterator_type __j = __i + __n;\n    return __b <= __j && __j <= __b + __cont->size();\n}\n\ntemplate <class _Container, class _Iter>\n__debug_iter<_Container, _Iter>&\n__debug_iter<_Container, _Iter>::operator+=(difference_type __n)\n{\n    assert(__can_add(__n));\n    __i += __n;\n    return *this;\n}\n\ntemplate <class _Container, class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)\n{\n    assert(__x.__cont && __x.__cont == __y.__cont);\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Container, class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Container, class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)\n{\n    assert(__x.__cont && __x.__cont == __y.__cont);\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Container, class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Container, class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Container, class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Container, class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __debug_iter<_Container, _Iter1>::difference_type\noperator-(const __debug_iter<_Container, _Iter1>& __x, const __debug_iter<_Container, _Iter2>& __y)\n{\n    assert(__x.__cont && __x.__cont == __y.__cont);\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Container, class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__debug_iter<_Container, _Iter>\noperator+(typename __debug_iter<_Container, _Iter>::difference_type __n,\n          const __debug_iter<_Container, _Iter>& __x)\n{\n    return __x + __n;\n}\n\n#endif  // _LIBCPP_DEBUG\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    wstring_convert(Codecvt* pcvt = new Codecvt);\n    wstring_convert(Codecvt* pcvt, state_type state);\n    wstring_convert(const byte_string& byte_err,\n                    const wide_string& wide_err = wide_string());\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const;\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());\n\n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#ifdef _LIBCPP_MSVCRT\n#include <support/win32/locale_win32.h>\n#else // _LIBCPP_MSVCRT\n#include <nl_types.h>\n#endif  // !_LIBCPP_MSVCRT\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n#ifndef _LIBCPP_LOCALE__L_EXTENSIONS\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&uselocale)> __locale_raii;\n#endif\n\n// OSX has nice foo_l() functions that let you turn off use of the global\n// locale.  Linux, not so much.  The following functions avoid the locale when\n// that's possible and otherwise do the wrong thing.  FIXME.\n#if defined(__linux__) || defined(__EMSCRIPTEN__)\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\ndecltype(MB_CUR_MAX_L(_VSTD::declval<locale_t>()))\ninline _LIBCPP_INLINE_VISIBILITY\n__mb_cur_max_l(locale_t __l)\n{\n  return MB_CUR_MAX_L(__l);\n}\n#else  // _LIBCPP_LOCALE__L_EXTENSIONS\n_LIBCPP_ALWAYS_INLINE inline\ndecltype(MB_CUR_MAX) __mb_cur_max_l(locale_t __l)\n{\n  __locale_raii __current(uselocale(__l), uselocale);\n  return MB_CUR_MAX;\n}\n#endif // _LIBCPP_LOCALE__L_EXTENSIONS\n\n_LIBCPP_ALWAYS_INLINE inline\nwint_t __btowc_l(int __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return btowc_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return btowc(__c);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nint __wctob_l(wint_t __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wctob_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wctob(__c);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nsize_t __wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcsnrtombs_l(__dest, __src, __nwc, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nsize_t __wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcrtomb_l(__s, __wc, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcrtomb(__s, __wc, __ps);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nsize_t __mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsnrtowcs_l(__dest, __src, __nms, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nsize_t __mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,\n                   mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrtowc_l(__pwc, __s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrtowc(__pwc, __s, __n, __ps);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nint __mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbtowc_l(__pwc, __pmb, __max, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbtowc(__pwc, __pmb, __max);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nsize_t __mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrlen_l(__s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrlen(__s, __n, __ps);\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nlconv *__localeconv_l(locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return localeconv_l(__l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return localeconv();\n#endif\n}\n\n_LIBCPP_ALWAYS_INLINE inline\nsize_t __mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,\n                     mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsrtowcs_l(__dest, __src, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsrtowcs(__dest, __src, __len, __ps);\n#endif\n}\n\ninline\nint __snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsnprintf_l(__s, __n, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsnprintf(__s, __n, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __asprintf_l(char **__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vasprintf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vasprintf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsscanf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsscanf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\n#endif  // __linux__\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_senstive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(struct __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE(struct __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long double __ld = strtold_l(__a, &__p2, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return static_cast<_Tp>(__ld);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        long& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<long>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        long long& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<long long>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        unsigned short& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<unsigned short>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        unsigned int& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<unsigned int>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        unsigned long& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<unsigned long>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        unsigned long long& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<unsigned long long>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        float& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<float>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        double& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<double>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        long double& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<long double>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __a[sizeof(__a)-1] = 0;\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    if (sscanf_l(__a, _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n#else\n    if (__sscanf_l(__a, __cloc(), \"%p\", &__v) != 1)\n#endif\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE(class num_get<wchar_t>)\n\nstruct __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE(struct __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE(struct __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE(class num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass __time_get_c_storage  // purposefully not decorated\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primatives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primatives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE(class time_get<wchar_t>)\n\nclass __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE(class time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE(class time_get_byname<wchar_t>)\n\nclass __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE(class time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE(class time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE(class time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE(class moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE(class __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\nvoid __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = __flags & ios_base::showbase;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE(class money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE(class __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __n = static_cast<size_t>(asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n#else\n        __n = __asprintf_l(&__bb, __cloc(), \"%.0Lf\", __units);\n#endif\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE(class money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _WIN32\n    return -1;\n#else // _WIN32\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _WIN32\n    return __dflt;\n#else // _WIN32\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#if !defined(_WIN32)\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // !_WIN32\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class messages<char>)\n_LIBCPP_EXTERN_TEMPLATE(class messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE(class messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE(class messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TYPE_VIS wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__wide_err_string_.empty())\n        throw range_error(\"wstring_convert: from_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__byte_err_string_.empty())\n        throw range_error(\"wstring_convert: to_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TYPE_VIS wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,\n                    state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    switch (__way)\n    {\n    case ios_base::beg:\n        break;\n    case ios_base::cur:\n        break;\n    case ios_base::end:\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n",null,"// -*- C++ -*-\n//===--------------------------- sstream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SSTREAM\n#define _LIBCPP_SSTREAM\n\n/*\n    sstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringbuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const basic_string<char_type, traits_type, allocator_type>& str,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    basic_stringbuf(basic_stringbuf&& rhs);\n\n    // 27.8.1.2 Assign and swap:\n    basic_stringbuf& operator=(basic_stringbuf&& rhs);\n    void swap(basic_stringbuf& rhs);\n\n    // 27.8.1.3 Get and set:\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type*, streamsize);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringbuf<charT, traits, Allocator>& x,\n            basic_stringbuf<charT, traits, Allocator>& y);\n\ntypedef basic_stringbuf<char>    stringbuf;\ntypedef basic_stringbuf<wchar_t> wstringbuf;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_istringstream\n    : public basic_istream<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode which = ios_base::in);\n    explicit basic_istringstream(const basic_string<char_type, traits_type,allocator_type>& str,\n                                 ios_base::openmode which = ios_base::in);\n    basic_istringstream(basic_istringstream&& rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& rhs);\n    void swap(basic_istringstream& rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_istringstream<charT, traits, Allocator>& x,\n            basic_istringstream<charT, traits, Allocator>& y);\n\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_istringstream<wchar_t> wistringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_ostringstream\n    : public basic_ostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.3.1 Constructors/destructor:\n    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);\n    explicit basic_ostringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                 ios_base::openmode which = ios_base::out);\n    basic_ostringstream(basic_ostringstream&& rhs);\n\n    // 27.8.3.2 Assign/swap:\n    basic_ostringstream& operator=(basic_ostringstream&& rhs);\n    void swap(basic_ostringstream& rhs);\n\n    // 27.8.3.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_ostringstream<charT, traits, Allocator>& x,\n            basic_ostringstream<charT, traits, Allocator>& y);\n\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringstream\n    : public basic_iostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // constructors/destructor\n    explicit basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in);\n    explicit basic_stringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                ios_base::openmode which = ios_base::out|ios_base::in);\n    basic_stringstream(basic_stringstream&& rhs);\n\n    // 27.8.5.1 Assign/swap:\n    basic_stringstream& operator=(basic_stringstream&& rhs);\n    void swap(basic_stringstream& rhs);\n\n    // Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& str);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringstream<charT, traits, Allocator>& x,\n            basic_stringstream<charT, traits, Allocator>& y);\n\ntypedef basic_stringstream<char>    stringstream;\ntypedef basic_stringstream<wchar_t> wstringstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <string>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// basic_stringbuf\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS basic_stringbuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n\n    string_type __str_;\n    mutable char_type* __hm_;\n    ios_base::openmode __mode_;\n\npublic:\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf(basic_stringbuf&& __rhs);\n#endif\n\n    // 27.8.1.2 Assign and swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf& operator=(basic_stringbuf&& __rhs);\n#endif\n    void swap(basic_stringbuf& __rhs);\n\n    // 27.8.1.3 Get and set:\n    string_type str() const;\n    void str(const string_type& __s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(string_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(__s);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)\n    : __mode_(__rhs.__mode_)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>&\nbasic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __mode_ = __rhs.__mode_;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __rbinp = -1;\n    ptrdiff_t __rninp = -1;\n    ptrdiff_t __reinp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __rbinp = __rhs.eback() - __p;\n        __rninp = __rhs.gptr() - __p;\n        __reinp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __rbout = -1;\n    ptrdiff_t __rnout = -1;\n    ptrdiff_t __reout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __rbout = __rhs.pbase() - __p;\n        __rnout = __rhs.pptr() - __p;\n        __reout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __p = const_cast<char_type*>(__str_.data());\n    ptrdiff_t __lbinp = -1;\n    ptrdiff_t __lninp = -1;\n    ptrdiff_t __leinp = -1;\n    if (this->eback() != nullptr)\n    {\n        __lbinp = this->eback() - __p;\n        __lninp = this->gptr() - __p;\n        __leinp = this->egptr() - __p;\n    }\n    ptrdiff_t __lbout = -1;\n    ptrdiff_t __lnout = -1;\n    ptrdiff_t __leout = -1;\n    if (this->pbase() != nullptr)\n    {\n        __lbout = this->pbase() - __p;\n        __lnout = this->pptr() - __p;\n        __leout = this->epptr() - __p;\n    }\n    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;\n    _VSTD::swap(__mode_, __rhs.__mode_);\n    __str_.swap(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__rbinp != -1)\n        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__rbout != -1)\n    {\n        this->setp(__p + __rbout, __p + __reout);\n        this->pbump(__rnout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    if (__lbinp != -1)\n        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);\n    else\n        __rhs.setg(nullptr, nullptr, nullptr);\n    if (__lbout != -1)\n    {\n        __rhs.setp(__p + __lbout, __p + __leout);\n        __rhs.pbump(__lnout);\n    }\n    else\n        __rhs.setp(nullptr, nullptr);\n    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;\n    locale __tl = __rhs.getloc();\n    __rhs.pubimbue(this->getloc());\n    this->pubimbue(__tl);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str() const\n{\n    if (__mode_ & ios_base::out)\n    {\n        if (__hm_ < this->pptr())\n            __hm_ = this->pptr();\n        return string_type(this->pbase(), __hm_, __str_.get_allocator());\n    }\n    else if (__mode_ & ios_base::in)\n        return string_type(this->eback(), this->egptr(), __str_.get_allocator());\n    return string_type(__str_.get_allocator());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __str_ = __s;\n    __hm_ = 0;\n    if (__mode_ & ios_base::in)\n    {\n        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();\n        this->setg(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()),\n                   __hm_);\n    }\n    if (__mode_ & ios_base::out)\n    {\n        typename string_type::size_type __sz = __str_.size();\n        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;\n        __str_.resize(__str_.capacity());\n        this->setp(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()) + __str_.size());\n        if (__mode_ & (ios_base::app | ios_base::ate))\n            this->pbump(__sz);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::underflow()\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (__mode_ & ios_base::in)\n    {\n        if (this->egptr() < __hm_)\n            this->setg(this->eback(), this->gptr(), __hm_);\n        if (this->gptr() < this->egptr())\n            return traits_type::to_int_type(*this->gptr());\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            return traits_type::not_eof(__c);\n        }\n        if ((__mode_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)\n{\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        ptrdiff_t __ninp = this->gptr()  - this->eback();\n        if (this->pptr() == this->epptr())\n        {\n            if (!(__mode_ & ios_base::out))\n                return traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                ptrdiff_t __nout = this->pptr()  - this->pbase();\n                ptrdiff_t __hm = __hm_ - this->pbase();\n                __str_.push_back(char_type());\n                __str_.resize(__str_.capacity());\n                char_type* __p = const_cast<char_type*>(__str_.data());\n                this->setp(__p, __p + __str_.size());\n                this->pbump(__nout);\n                __hm_ = this->pbase() + __hm;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                return traits_type::eof();\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        }\n        __hm_ = _VSTD::max(this->pptr() + 1, __hm_);\n        if (__mode_ & ios_base::in)\n        {\n            char_type* __p = const_cast<char_type*>(__str_.data());\n            this->setg(__p, __p + __ninp, __hm_);\n        }\n        return this->sputc(__c);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,\n                                                      ios_base::seekdir __way,\n                                                      ios_base::openmode __wch)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if ((__wch & (ios_base::in | ios_base::out)) == 0)\n        return pos_type(-1);\n    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)\n        && __way == ios_base::cur)\n        return pos_type(-1);\n    off_type __noff;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __noff = 0;\n        break;\n    case ios_base::cur:\n        if (__wch & ios_base::in)\n            __noff = this->gptr() - this->eback();\n        else\n            __noff = this->pptr() - this->pbase();\n        break;\n    case ios_base::end:\n        __noff = __hm_ - __str_.data();\n        break;\n    default:\n        return pos_type(-1);\n    }\n    __noff += __off;\n    if (__noff < 0 || __hm_ - __str_.data() < __noff)\n        return pos_type(-1);\n    if (__noff != 0)\n    {\n        if ((__wch & ios_base::in) && this->gptr() == 0)\n            return pos_type(-1);\n        if ((__wch & ios_base::out) && this->pptr() == 0)\n            return pos_type(-1);\n    }\n    if (__wch & ios_base::in)\n        this->setg(this->eback(), this->eback() + __noff, __hm_);\n    if (__wch & ios_base::out)\n    {\n        this->setp(this->pbase(), this->epptr());\n        this->pbump(__noff);\n    }\n    return pos_type(__noff);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,\n                                                      ios_base::openmode __wch)\n{\n    return seekoff(__sp, ios_base::beg, __wch);\n}\n\n// basic_istringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS basic_istringstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);\n    explicit basic_istringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_istringstream(basic_istringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_istringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::in)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::in)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>&\nbasic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_ostringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS basic_ostringstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);\n    explicit basic_ostringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ostringstream(basic_ostringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_ostringstream& operator=(basic_ostringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_ostringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::out)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::out)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)\n    : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>&\nbasic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_stringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS basic_stringstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringstream(const string_type& __s,\n                                ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringstream(basic_stringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_stringstream& operator=(basic_stringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_stringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,\n                                                                    ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)\n    : basic_iostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>&\nbasic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SSTREAM\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}