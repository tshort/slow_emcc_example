/* Simulation code for Modelica.Electrical.Analog.Examples.Rectifier generated by the OpenModelica Compiler 1.9.1+dev (r17647). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation_info_xml.h"
#include "simulation_runtime.h"
#include "omc_error.h"
#include "model_help.h"

#include <assert.h>
#include <string.h>

#include "Modelica.Electrical.Analog.Examples.Rectifier_functions.h"

#include "Modelica.Electrical.Analog.Examples.Rectifier_model.h"
#include "Modelica.Electrical.Analog.Examples.Rectifier_functions.c"
/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _OMC_MEASURE_TIME
int measure_time_flag = 1;
#else
int measure_time_flag = 0;
#endif


#if defined(HPCOM)
  #if !defined(_OPENMP)
    #error "HPCOM requires OpenMP or the results are wrong"
  #endif
  #include <omp.h>
  #include <perform_simulation.c>
#elif defined(_OPENMP)
  #include <omp.h>
  #include <omp_perform_simulation.c>
#else
  #include <perform_simulation.c>
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif


#define threadData data->threadData
void setupDataStruc(DATA *data)
{
  ASSERT(data, "Error while initialize Data");
  data->modelData.modelName = "Modelica.Electrical.Analog.Examples.Rectifier";
  data->modelData.modelFilePrefix = "Modelica.Electrical.Analog.Examples.Rectifier";
  data->modelData.modelDir = "/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Examples";
  data->modelData.modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  #ifdef OPENMODELICA_XML_FROM_FILE_AT_RUNTIME
  data->modelData.initXMLData = NULL;
  data->modelData.modelDataXml.infoXMLData = NULL;
  #else
  #include "Modelica.Electrical.Analog.Examples.Rectifier_init.c"
  #include "Modelica.Electrical.Analog.Examples.Rectifier_info.c"
  #endif
  
  data->modelData.nStates = 4;
  data->modelData.nVariablesReal = 2*4+51;
  data->modelData.nDiscreteReal = 0;
  data->modelData.nVariablesInteger = 0;
  data->modelData.nVariablesBoolean = 6;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 68;
  data->modelData.nParametersInteger = 0;
  data->modelData.nParametersBoolean = 6;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 0;
  data->modelData.nOutputVars = 8;
  data->modelData.nJacobians = 5;
  
  data->modelData.nAliasReal = 68;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 0;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 9;
  data->modelData.nSamples = 0;
  data->modelData.nRelations = 9;
  data->modelData.nMathEvents = 0;
  data->modelData.nInitEquations = 2;
  data->modelData.nInitAlgorithms = 0;
  data->modelData.nInitResiduals = 2;    /* data->modelData.nInitEquations + data->modelData.nInitAlgorithms */
  data->modelData.nExtObjs = 0;
  data->modelData.modelDataXml.fileName = "Modelica.Electrical.Analog.Examples.Rectifier_info.xml";
  data->modelData.modelDataXml.nFunctions = 0;
  data->modelData.modelDataXml.nProfileBlocks = 0;
  data->modelData.modelDataXml.nEquations = 232;
  data->modelData.nMixedSystems = 0;
  data->modelData.nLinearSystems = 2;
  data->modelData.nNonLinearSystems = 6;
  data->modelData.nStateSets = 0;
  data->modelData.nInlineVars = 0;
  
  data->modelData.nDelayExpressions = 0;
  
}


/* Has to be performed after _init.xml file has been read */
void callExternalObjectConstructors(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  /* data->simulationInfo.extObjs = NULL; */
  INFO(LOG_DEBUG, "call external Object Constructors");
  INFO(LOG_DEBUG, "call external Object Constructors finished");
}

void callExternalObjectDestructors(DATA *data)
{
  if(data->simulationInfo.extObjs)
  {
    free(data->simulationInfo.extObjs);
    data->simulationInfo.extObjs = 0;
  }
}


/*
 equation index: 53
 type: SIMPLE_ASSIGN
 IdealDiode1._off = IdealDiode1.s < 0.0
 */
static void eqFunction_53(DATA *data)
{
  modelica_boolean tmp1069;
  RELATIONHYSTERESIS(tmp1069, $PIdealDiode1$Ps, 0.0, 5, Less);
  $PIdealDiode1$Poff = tmp1069;
}
/*
 equation index: 54
 type: SIMPLE_ASSIGN
 IdealDiode4._off = IdealDiode4.s < 0.0
 */
static void eqFunction_54(DATA *data)
{
  modelica_boolean tmp1070;
  RELATIONHYSTERESIS(tmp1070, $PIdealDiode4$Ps, 0.0, 4, Less);
  $PIdealDiode4$Poff = tmp1070;
}
/*
 equation index: 55
 type: SIMPLE_ASSIGN
 IdealDiode1._i = IdealDiode1.s * (if IdealDiode1.off then IdealDiode1.Goff else 1.0) + IdealDiode1.Goff * IdealDiode1.Vknee
 */
static void eqFunction_55(DATA *data)
{
  $PIdealDiode1$Pi = (($PIdealDiode1$Ps * ($PIdealDiode1$Poff?$PIdealDiode1$PGoff:1.0)) + ($PIdealDiode1$PGoff * $PIdealDiode1$PVknee));
}
/*
 equation index: 56
 type: SIMPLE_ASSIGN
 IdealDiode4._i = IdealDiode1.i - iAC[1]
 */
static void eqFunction_56(DATA *data)
{
  $PIdealDiode4$Pi = ($PIdealDiode1$Pi - $PiAC$lB1$rB);
}
/*
 equation index: 57
 type: SIMPLE_ASSIGN
 IdealDiode1._v = IdealDiode1.s * (if IdealDiode1.off then 1.0 else IdealDiode1.Ron) + IdealDiode1.Vknee
 */
static void eqFunction_57(DATA *data)
{
  $PIdealDiode1$Pv = (($PIdealDiode1$Ps * ($PIdealDiode1$Poff?1.0:$PIdealDiode1$PRon)) + $PIdealDiode1$PVknee);
}
/*
 equation index: 58
 type: SIMPLE_ASSIGN
 IdealDiode1._p._v = IdealDiode1.v + Capacitor1.v
 */
static void eqFunction_58(DATA *data)
{
  $PIdealDiode1$Pp$Pv = ($PIdealDiode1$Pv + $PCapacitor1$Pv);
}
/*
 equation index: 59
 type: SIMPLE_ASSIGN
 IdealDiode4._v = (-Capacitor2.v) - IdealDiode1.p.v
 */
static void eqFunction_59(DATA *data)
{
  $PIdealDiode4$Pv = ((-$PCapacitor2$Pv) - $PIdealDiode1$Pp$Pv);
}
void initializeStaticNLSData62(void *inData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $PIdealDiode4$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode4$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode4$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode4$Ps.max;
  /* static nls data for $PIdealDiode1$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode1$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode1$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode1$Ps.max;
}

void residualFunc62(void* dataIn, double* xloc, double* res, integer* iflag)
{
  DATA* data = (DATA*) dataIn;
  state mem_state;
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,62).profileBlockIndex,1);
  #endif
  mem_state = get_memory_state();
  $PIdealDiode4$Ps = xloc[0];
  $PIdealDiode1$Ps = xloc[1];
  eqFunction_53(data);
  eqFunction_54(data);
  eqFunction_55(data);
  eqFunction_56(data);
  eqFunction_57(data);
  eqFunction_58(data);
  eqFunction_59(data);
  res[0] = ($PIdealDiode4$Pi + (((-$PIdealDiode4$PGoff) * $PIdealDiode4$PVknee) + ((-$PIdealDiode4$Ps) * ($PIdealDiode4$Poff?$PIdealDiode4$PGoff:1.0))));
  res[1] = ($PIdealDiode4$Pv + (((-$PIdealDiode4$Ps) * ($PIdealDiode4$Poff?1.0:$PIdealDiode4$PRon)) - $PIdealDiode4$PVknee));
  restore_memory_state(mem_state);
}


/*
 equation index: 65
 type: SIMPLE_ASSIGN
 IdealDiode2._off = IdealDiode2.s < 0.0
 */
static void eqFunction_65(DATA *data)
{
  modelica_boolean tmp1071;
  RELATIONHYSTERESIS(tmp1071, $PIdealDiode2$Ps, 0.0, 3, Less);
  $PIdealDiode2$Poff = tmp1071;
}
/*
 equation index: 66
 type: SIMPLE_ASSIGN
 IdealDiode5._off = IdealDiode5.s < 0.0
 */
static void eqFunction_66(DATA *data)
{
  modelica_boolean tmp1072;
  RELATIONHYSTERESIS(tmp1072, $PIdealDiode5$Ps, 0.0, 2, Less);
  $PIdealDiode5$Poff = tmp1072;
}
/*
 equation index: 67
 type: SIMPLE_ASSIGN
 IdealDiode2._i = IdealDiode2.s * (if IdealDiode2.off then IdealDiode2.Goff else 1.0) + IdealDiode2.Goff * IdealDiode2.Vknee
 */
static void eqFunction_67(DATA *data)
{
  $PIdealDiode2$Pi = (($PIdealDiode2$Ps * ($PIdealDiode2$Poff?$PIdealDiode2$PGoff:1.0)) + ($PIdealDiode2$PGoff * $PIdealDiode2$PVknee));
}
/*
 equation index: 68
 type: SIMPLE_ASSIGN
 IdealDiode5._i = IdealDiode2.i - Inductor2.i
 */
static void eqFunction_68(DATA *data)
{
  $PIdealDiode5$Pi = ($PIdealDiode2$Pi - $PInductor2$Pi);
}
/*
 equation index: 69
 type: SIMPLE_ASSIGN
 IdealDiode2._v = IdealDiode2.s * (if IdealDiode2.off then 1.0 else IdealDiode2.Ron) + IdealDiode2.Vknee
 */
static void eqFunction_69(DATA *data)
{
  $PIdealDiode2$Pv = (($PIdealDiode2$Ps * ($PIdealDiode2$Poff?1.0:$PIdealDiode2$PRon)) + $PIdealDiode2$PVknee);
}
/*
 equation index: 70
 type: SIMPLE_ASSIGN
 IdealDiode2._p._v = IdealDiode2.v + Capacitor1.v
 */
static void eqFunction_70(DATA *data)
{
  $PIdealDiode2$Pp$Pv = ($PIdealDiode2$Pv + $PCapacitor1$Pv);
}
/*
 equation index: 71
 type: SIMPLE_ASSIGN
 IdealDiode5._v = (-Capacitor2.v) - IdealDiode2.p.v
 */
static void eqFunction_71(DATA *data)
{
  $PIdealDiode5$Pv = ((-$PCapacitor2$Pv) - $PIdealDiode2$Pp$Pv);
}
void initializeStaticNLSData74(void *inData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $PIdealDiode5$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode5$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode5$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode5$Ps.max;
  /* static nls data for $PIdealDiode2$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode2$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode2$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode2$Ps.max;
}

void residualFunc74(void* dataIn, double* xloc, double* res, integer* iflag)
{
  DATA* data = (DATA*) dataIn;
  state mem_state;
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,74).profileBlockIndex,1);
  #endif
  mem_state = get_memory_state();
  $PIdealDiode5$Ps = xloc[0];
  $PIdealDiode2$Ps = xloc[1];
  eqFunction_65(data);
  eqFunction_66(data);
  eqFunction_67(data);
  eqFunction_68(data);
  eqFunction_69(data);
  eqFunction_70(data);
  eqFunction_71(data);
  res[0] = ($PIdealDiode5$Pi + (((-$PIdealDiode5$PGoff) * $PIdealDiode5$PVknee) + ((-$PIdealDiode5$Ps) * ($PIdealDiode5$Poff?$PIdealDiode5$PGoff:1.0))));
  res[1] = ($PIdealDiode5$Pv + (((-$PIdealDiode5$Ps) * ($PIdealDiode5$Poff?1.0:$PIdealDiode5$PRon)) - $PIdealDiode5$PVknee));
  restore_memory_state(mem_state);
}


/*
 equation index: 78
 type: SIMPLE_ASSIGN
 IdealDiode3._off = IdealDiode3.s < 0.0
 */
static void eqFunction_78(DATA *data)
{
  modelica_boolean tmp1073;
  RELATIONHYSTERESIS(tmp1073, $PIdealDiode3$Ps, 0.0, 1, Less);
  $PIdealDiode3$Poff = tmp1073;
}
/*
 equation index: 79
 type: SIMPLE_ASSIGN
 IdealDiode6._off = IdealDiode6.s < 0.0
 */
static void eqFunction_79(DATA *data)
{
  modelica_boolean tmp1074;
  RELATIONHYSTERESIS(tmp1074, $PIdealDiode6$Ps, 0.0, 0, Less);
  $PIdealDiode6$Poff = tmp1074;
}
/*
 equation index: 80
 type: SIMPLE_ASSIGN
 IdealDiode3._i = IdealDiode3.s * (if IdealDiode3.off then IdealDiode3.Goff else 1.0) + IdealDiode3.Goff * IdealDiode3.Vknee
 */
static void eqFunction_80(DATA *data)
{
  $PIdealDiode3$Pi = (($PIdealDiode3$Ps * ($PIdealDiode3$Poff?$PIdealDiode3$PGoff:1.0)) + ($PIdealDiode3$PGoff * $PIdealDiode3$PVknee));
}
/*
 equation index: 81
 type: SIMPLE_ASSIGN
 IdealDiode6._i = IdealDiode3.i - Inductor3.i
 */
static void eqFunction_81(DATA *data)
{
  $PIdealDiode6$Pi = ($PIdealDiode3$Pi - $PInductor3$Pi);
}
/*
 equation index: 82
 type: SIMPLE_ASSIGN
 IdealDiode3._v = IdealDiode3.s * (if IdealDiode3.off then 1.0 else IdealDiode3.Ron) + IdealDiode3.Vknee
 */
static void eqFunction_82(DATA *data)
{
  $PIdealDiode3$Pv = (($PIdealDiode3$Ps * ($PIdealDiode3$Poff?1.0:$PIdealDiode3$PRon)) + $PIdealDiode3$PVknee);
}
/*
 equation index: 83
 type: SIMPLE_ASSIGN
 IdealDiode3._p._v = IdealDiode3.v + Capacitor1.v
 */
static void eqFunction_83(DATA *data)
{
  $PIdealDiode3$Pp$Pv = ($PIdealDiode3$Pv + $PCapacitor1$Pv);
}
/*
 equation index: 84
 type: SIMPLE_ASSIGN
 IdealDiode6._v = (-Capacitor2.v) - IdealDiode3.p.v
 */
static void eqFunction_84(DATA *data)
{
  $PIdealDiode6$Pv = ((-$PCapacitor2$Pv) - $PIdealDiode3$Pp$Pv);
}
void initializeStaticNLSData87(void *inData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $PIdealDiode6$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode6$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode6$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode6$Ps.max;
  /* static nls data for $PIdealDiode3$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode3$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode3$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode3$Ps.max;
}

void residualFunc87(void* dataIn, double* xloc, double* res, integer* iflag)
{
  DATA* data = (DATA*) dataIn;
  state mem_state;
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,87).profileBlockIndex,1);
  #endif
  mem_state = get_memory_state();
  $PIdealDiode6$Ps = xloc[0];
  $PIdealDiode3$Ps = xloc[1];
  eqFunction_78(data);
  eqFunction_79(data);
  eqFunction_80(data);
  eqFunction_81(data);
  eqFunction_82(data);
  eqFunction_83(data);
  eqFunction_84(data);
  res[0] = ($PIdealDiode6$Pi + (((-$PIdealDiode6$PGoff) * $PIdealDiode6$PVknee) + ((-$PIdealDiode6$Ps) * ($PIdealDiode6$Poff?$PIdealDiode6$PGoff:1.0))));
  res[1] = ($PIdealDiode6$Pv + (((-$PIdealDiode6$Ps) * ($PIdealDiode6$Poff?1.0:$PIdealDiode6$PRon)) - $PIdealDiode6$PVknee));
  restore_memory_state(mem_state);
}

/*
 equation index: 109
 type: SIMPLE_ASSIGN
 IdealDiode5._off = IdealDiode5.s < 0.0
 */
static void eqFunction_109(DATA *data)
{
  modelica_boolean tmp1075;
  RELATIONHYSTERESIS(tmp1075, $PIdealDiode5$Ps, 0.0, 2, Less);
  $PIdealDiode5$Poff = tmp1075;
}
/*
 equation index: 110
 type: SIMPLE_ASSIGN
 IdealDiode2._off = IdealDiode2.s < 0.0
 */
static void eqFunction_110(DATA *data)
{
  modelica_boolean tmp1076;
  RELATIONHYSTERESIS(tmp1076, $PIdealDiode2$Ps, 0.0, 3, Less);
  $PIdealDiode2$Poff = tmp1076;
}
/*
 equation index: 111
 type: SIMPLE_ASSIGN
 IdealDiode2._v = IdealDiode2.s * (if IdealDiode2.off then 1.0 else IdealDiode2.Ron) + IdealDiode2.Vknee
 */
static void eqFunction_111(DATA *data)
{
  $PIdealDiode2$Pv = (($PIdealDiode2$Ps * ($PIdealDiode2$Poff?1.0:$PIdealDiode2$PRon)) + $PIdealDiode2$PVknee);
}
/*
 equation index: 112
 type: SIMPLE_ASSIGN
 IdealDiode2._p._v = IdealDiode2.v + Capacitor1.v
 */
static void eqFunction_112(DATA *data)
{
  $PIdealDiode2$Pp$Pv = ($PIdealDiode2$Pv + $PCapacitor1$Pv);
}
/*
 equation index: 113
 type: SIMPLE_ASSIGN
 IdealDiode5._v = (-Capacitor2.v) - IdealDiode2.p.v
 */
static void eqFunction_113(DATA *data)
{
  $PIdealDiode5$Pv = ((-$PCapacitor2$Pv) - $PIdealDiode2$Pp$Pv);
}
/*
 equation index: 114
 type: SIMPLE_ASSIGN
 IdealDiode2._i = IdealDiode2.s * (if IdealDiode2.off then IdealDiode2.Goff else 1.0) + IdealDiode2.Goff * IdealDiode2.Vknee
 */
static void eqFunction_114(DATA *data)
{
  $PIdealDiode2$Pi = (($PIdealDiode2$Ps * ($PIdealDiode2$Poff?$PIdealDiode2$PGoff:1.0)) + ($PIdealDiode2$PGoff * $PIdealDiode2$PVknee));
}
/*
 equation index: 115
 type: SIMPLE_ASSIGN
 IdealDiode5._i = IdealDiode2.i - Inductor2.i
 */
static void eqFunction_115(DATA *data)
{
  $PIdealDiode5$Pi = ($PIdealDiode2$Pi - $PInductor2$Pi);
}
void initializeStaticNLSData118(void *inData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $PIdealDiode5$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode5$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode5$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode5$Ps.max;
  /* static nls data for $PIdealDiode2$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode2$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode2$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode2$Ps.max;
}

void residualFunc118(void* dataIn, double* xloc, double* res, integer* iflag)
{
  DATA* data = (DATA*) dataIn;
  state mem_state;
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,118).profileBlockIndex,1);
  #endif
  mem_state = get_memory_state();
  $PIdealDiode5$Ps = xloc[0];
  $PIdealDiode2$Ps = xloc[1];
  eqFunction_109(data);
  eqFunction_110(data);
  eqFunction_111(data);
  eqFunction_112(data);
  eqFunction_113(data);
  eqFunction_114(data);
  eqFunction_115(data);
  res[0] = ($PIdealDiode5$Pi + (((-$PIdealDiode5$PGoff) * $PIdealDiode5$PVknee) + ((-$PIdealDiode5$Ps) * ($PIdealDiode5$Poff?$PIdealDiode5$PGoff:1.0))));
  res[1] = ($PIdealDiode5$Pv + (((-$PIdealDiode5$Ps) * ($PIdealDiode5$Poff?1.0:$PIdealDiode5$PRon)) - $PIdealDiode5$PVknee));
  restore_memory_state(mem_state);
}


/*
 equation index: 121
 type: SIMPLE_ASSIGN
 IdealDiode6._off = IdealDiode6.s < 0.0
 */
static void eqFunction_121(DATA *data)
{
  modelica_boolean tmp1077;
  RELATIONHYSTERESIS(tmp1077, $PIdealDiode6$Ps, 0.0, 0, Less);
  $PIdealDiode6$Poff = tmp1077;
}
/*
 equation index: 122
 type: SIMPLE_ASSIGN
 IdealDiode3._off = IdealDiode3.s < 0.0
 */
static void eqFunction_122(DATA *data)
{
  modelica_boolean tmp1078;
  RELATIONHYSTERESIS(tmp1078, $PIdealDiode3$Ps, 0.0, 1, Less);
  $PIdealDiode3$Poff = tmp1078;
}
/*
 equation index: 123
 type: SIMPLE_ASSIGN
 IdealDiode3._v = IdealDiode3.s * (if IdealDiode3.off then 1.0 else IdealDiode3.Ron) + IdealDiode3.Vknee
 */
static void eqFunction_123(DATA *data)
{
  $PIdealDiode3$Pv = (($PIdealDiode3$Ps * ($PIdealDiode3$Poff?1.0:$PIdealDiode3$PRon)) + $PIdealDiode3$PVknee);
}
/*
 equation index: 124
 type: SIMPLE_ASSIGN
 IdealDiode3._p._v = IdealDiode3.v + Capacitor1.v
 */
static void eqFunction_124(DATA *data)
{
  $PIdealDiode3$Pp$Pv = ($PIdealDiode3$Pv + $PCapacitor1$Pv);
}
/*
 equation index: 125
 type: SIMPLE_ASSIGN
 IdealDiode6._v = (-Capacitor2.v) - IdealDiode3.p.v
 */
static void eqFunction_125(DATA *data)
{
  $PIdealDiode6$Pv = ((-$PCapacitor2$Pv) - $PIdealDiode3$Pp$Pv);
}
/*
 equation index: 126
 type: SIMPLE_ASSIGN
 IdealDiode3._i = IdealDiode3.s * (if IdealDiode3.off then IdealDiode3.Goff else 1.0) + IdealDiode3.Goff * IdealDiode3.Vknee
 */
static void eqFunction_126(DATA *data)
{
  $PIdealDiode3$Pi = (($PIdealDiode3$Ps * ($PIdealDiode3$Poff?$PIdealDiode3$PGoff:1.0)) + ($PIdealDiode3$PGoff * $PIdealDiode3$PVknee));
}
/*
 equation index: 127
 type: SIMPLE_ASSIGN
 IdealDiode6._i = IdealDiode3.i - Inductor3.i
 */
static void eqFunction_127(DATA *data)
{
  $PIdealDiode6$Pi = ($PIdealDiode3$Pi - $PInductor3$Pi);
}
void initializeStaticNLSData130(void *inData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $PIdealDiode6$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode6$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode6$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode6$Ps.max;
  /* static nls data for $PIdealDiode3$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode3$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode3$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode3$Ps.max;
}

void residualFunc130(void* dataIn, double* xloc, double* res, integer* iflag)
{
  DATA* data = (DATA*) dataIn;
  state mem_state;
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,130).profileBlockIndex,1);
  #endif
  mem_state = get_memory_state();
  $PIdealDiode6$Ps = xloc[0];
  $PIdealDiode3$Ps = xloc[1];
  eqFunction_121(data);
  eqFunction_122(data);
  eqFunction_123(data);
  eqFunction_124(data);
  eqFunction_125(data);
  eqFunction_126(data);
  eqFunction_127(data);
  res[0] = ($PIdealDiode6$Pi + (((-$PIdealDiode6$PGoff) * $PIdealDiode6$PVknee) + ((-$PIdealDiode6$Ps) * ($PIdealDiode6$Poff?$PIdealDiode6$PGoff:1.0))));
  res[1] = ($PIdealDiode6$Pv + (((-$PIdealDiode6$Ps) * ($PIdealDiode6$Poff?1.0:$PIdealDiode6$PRon)) - $PIdealDiode6$PVknee));
  restore_memory_state(mem_state);
}


/*
 equation index: 138
 type: SIMPLE_ASSIGN
 IdealDiode4._off = IdealDiode4.s < 0.0
 */
static void eqFunction_138(DATA *data)
{
  modelica_boolean tmp1079;
  RELATIONHYSTERESIS(tmp1079, $PIdealDiode4$Ps, 0.0, 4, Less);
  $PIdealDiode4$Poff = tmp1079;
}
/*
 equation index: 139
 type: SIMPLE_ASSIGN
 IdealDiode1._off = IdealDiode1.s < 0.0
 */
static void eqFunction_139(DATA *data)
{
  modelica_boolean tmp1080;
  RELATIONHYSTERESIS(tmp1080, $PIdealDiode1$Ps, 0.0, 5, Less);
  $PIdealDiode1$Poff = tmp1080;
}
/*
 equation index: 140
 type: SIMPLE_ASSIGN
 IdealDiode1._v = IdealDiode1.s * (if IdealDiode1.off then 1.0 else IdealDiode1.Ron) + IdealDiode1.Vknee
 */
static void eqFunction_140(DATA *data)
{
  $PIdealDiode1$Pv = (($PIdealDiode1$Ps * ($PIdealDiode1$Poff?1.0:$PIdealDiode1$PRon)) + $PIdealDiode1$PVknee);
}
/*
 equation index: 141
 type: SIMPLE_ASSIGN
 IdealDiode1._p._v = IdealDiode1.v + Capacitor1.v
 */
static void eqFunction_141(DATA *data)
{
  $PIdealDiode1$Pp$Pv = ($PIdealDiode1$Pv + $PCapacitor1$Pv);
}
/*
 equation index: 142
 type: SIMPLE_ASSIGN
 IdealDiode4._v = (-Capacitor2.v) - IdealDiode1.p.v
 */
static void eqFunction_142(DATA *data)
{
  $PIdealDiode4$Pv = ((-$PCapacitor2$Pv) - $PIdealDiode1$Pp$Pv);
}
/*
 equation index: 143
 type: SIMPLE_ASSIGN
 IdealDiode1._i = IdealDiode1.s * (if IdealDiode1.off then IdealDiode1.Goff else 1.0) + IdealDiode1.Goff * IdealDiode1.Vknee
 */
static void eqFunction_143(DATA *data)
{
  $PIdealDiode1$Pi = (($PIdealDiode1$Ps * ($PIdealDiode1$Poff?$PIdealDiode1$PGoff:1.0)) + ($PIdealDiode1$PGoff * $PIdealDiode1$PVknee));
}
/*
 equation index: 144
 type: SIMPLE_ASSIGN
 IdealDiode4._i = IdealDiode1.i - iAC[1]
 */
static void eqFunction_144(DATA *data)
{
  $PIdealDiode4$Pi = ($PIdealDiode1$Pi - $PiAC$lB1$rB);
}
void initializeStaticNLSData147(void *inData, void *inNlsData)
{
  DATA* data = (DATA*) inData;
  NONLINEAR_SYSTEM_DATA* nlsData = (NONLINEAR_SYSTEM_DATA*) inNlsData;
  int i=0;
  /* static nls data for $PIdealDiode4$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode4$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode4$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode4$Ps.max;
  /* static nls data for $PIdealDiode1$Ps */
  nlsData->nominal[i] = $P$ATTRIBUTE$PIdealDiode1$Ps.nominal;
  nlsData->min[i]     = $P$ATTRIBUTE$PIdealDiode1$Ps.min;
  nlsData->max[i++]   = $P$ATTRIBUTE$PIdealDiode1$Ps.max;
}

void residualFunc147(void* dataIn, double* xloc, double* res, integer* iflag)
{
  DATA* data = (DATA*) dataIn;
  state mem_state;
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,147).profileBlockIndex,1);
  #endif
  mem_state = get_memory_state();
  $PIdealDiode4$Ps = xloc[0];
  $PIdealDiode1$Ps = xloc[1];
  eqFunction_138(data);
  eqFunction_139(data);
  eqFunction_140(data);
  eqFunction_141(data);
  eqFunction_142(data);
  eqFunction_143(data);
  eqFunction_144(data);
  res[0] = ($PIdealDiode4$Pv + (((-$PIdealDiode4$Ps) * ($PIdealDiode4$Poff?1.0:$PIdealDiode4$PRon)) - $PIdealDiode4$PVknee));
  res[1] = ($PIdealDiode4$Pi + (((-$PIdealDiode4$PGoff) * $PIdealDiode4$PVknee) + ((-$PIdealDiode4$Ps) * ($PIdealDiode4$Poff?$PIdealDiode4$PGoff:1.0))));
  restore_memory_state(mem_state);
}

/* funtion initialize non-linear systems */
void initialNonLinearSystem(NONLINEAR_SYSTEM_DATA* nonLinearSystemData)
{
  nonLinearSystemData[0].equationIndex = 62;
  nonLinearSystemData[0].size = 2;
  nonLinearSystemData[0].method = 0;
  nonLinearSystemData[0].residualFunc = residualFunc62;
  nonLinearSystemData[0].analyticalJacobianColumn = NULL;
  nonLinearSystemData[0].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[0].jacobianIndex = -1;
  nonLinearSystemData[0].initializeStaticNLSData = initializeStaticNLSData62;
  
  
  
  nonLinearSystemData[1].equationIndex = 74;
  nonLinearSystemData[1].size = 2;
  nonLinearSystemData[1].method = 0;
  nonLinearSystemData[1].residualFunc = residualFunc74;
  nonLinearSystemData[1].analyticalJacobianColumn = NULL;
  nonLinearSystemData[1].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[1].jacobianIndex = -1;
  nonLinearSystemData[1].initializeStaticNLSData = initializeStaticNLSData74;
  
  
  
  nonLinearSystemData[2].equationIndex = 87;
  nonLinearSystemData[2].size = 2;
  nonLinearSystemData[2].method = 0;
  nonLinearSystemData[2].residualFunc = residualFunc87;
  nonLinearSystemData[2].analyticalJacobianColumn = NULL;
  nonLinearSystemData[2].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[2].jacobianIndex = -1;
  nonLinearSystemData[2].initializeStaticNLSData = initializeStaticNLSData87;
  
  nonLinearSystemData[3].equationIndex = 118;
  nonLinearSystemData[3].size = 2;
  nonLinearSystemData[3].method = 0;
  nonLinearSystemData[3].residualFunc = residualFunc118;
  nonLinearSystemData[3].analyticalJacobianColumn = NULL;
  nonLinearSystemData[3].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[3].jacobianIndex = -1;
  nonLinearSystemData[3].initializeStaticNLSData = initializeStaticNLSData118;
  
  
  
  nonLinearSystemData[4].equationIndex = 130;
  nonLinearSystemData[4].size = 2;
  nonLinearSystemData[4].method = 0;
  nonLinearSystemData[4].residualFunc = residualFunc130;
  nonLinearSystemData[4].analyticalJacobianColumn = NULL;
  nonLinearSystemData[4].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[4].jacobianIndex = -1;
  nonLinearSystemData[4].initializeStaticNLSData = initializeStaticNLSData130;
  
  
  
  nonLinearSystemData[5].equationIndex = 147;
  nonLinearSystemData[5].size = 2;
  nonLinearSystemData[5].method = 0;
  nonLinearSystemData[5].residualFunc = residualFunc147;
  nonLinearSystemData[5].analyticalJacobianColumn = NULL;
  nonLinearSystemData[5].initialAnalyticalJacobian = NULL;
  nonLinearSystemData[5].jacobianIndex = -1;
  nonLinearSystemData[5].initializeStaticNLSData = initializeStaticNLSData147;
  
}

/* initial linear systems */
void setLinearMatrixA96(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->setAElement(0, 3, 1.0, 0, linearSystemData);
  linearSystemData->setAElement(0, 9, -1.0, 1, linearSystemData);
  linearSystemData->setAElement(1, 8, 1.0, 2, linearSystemData);
  linearSystemData->setAElement(1, 9, -1.0, 3, linearSystemData);
  linearSystemData->setAElement(2, 7, -1.0, 4, linearSystemData);
  linearSystemData->setAElement(2, 8, 1.0, 5, linearSystemData);
  linearSystemData->setAElement(3, 6, 1.0, 6, linearSystemData);
  linearSystemData->setAElement(3, 7, -1.0, 7, linearSystemData);
  linearSystemData->setAElement(4, 5, $PInductor1$PL, 8, linearSystemData);
  linearSystemData->setAElement(4, 6, -1.0, 9, linearSystemData);
  linearSystemData->setAElement(5, 0, 1.0, 10, linearSystemData);
  linearSystemData->setAElement(5, 4, 1.0, 11, linearSystemData);
  linearSystemData->setAElement(5, 5, 1.0, 12, linearSystemData);
  linearSystemData->setAElement(6, 3, -1.0, 13, linearSystemData);
  linearSystemData->setAElement(6, 4, $PInductor3$PL, 14, linearSystemData);
  linearSystemData->setAElement(7, 2, -1.0, 15, linearSystemData);
  linearSystemData->setAElement(7, 8, 1.0, 16, linearSystemData);
  linearSystemData->setAElement(8, 1, 1.0, 17, linearSystemData);
  linearSystemData->setAElement(8, 2, -1.0, 18, linearSystemData);
  linearSystemData->setAElement(9, 0, $PInductor2$PL, 19, linearSystemData);
  linearSystemData->setAElement(9, 1, -1.0, 20, linearSystemData);
}
void setLinearVectorb96(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->b[0] =  (-$PIdealDiode3$Pp$Pv);
  linearSystemData->b[1] =  (-$PSineVoltage3$Pv);
  linearSystemData->b[2] =  (-$PSineVoltage1$Pv);
  linearSystemData->b[3] =  (-$PIdealDiode1$Pp$Pv);
  linearSystemData->b[4] =  0.0;
  linearSystemData->b[5] =  0.0;
  linearSystemData->b[6] =  0.0;
  linearSystemData->b[7] =  (-$PSineVoltage2$Pv);
  linearSystemData->b[8] =  (-$PIdealDiode2$Pp$Pv);
  linearSystemData->b[9] =  0.0;

}
/* inline linear systems */
/* parameter linear systems */
/* model linear systems */
void setLinearMatrixA153(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->setAElement(0, 0, -1.0, 0, linearSystemData);
  linearSystemData->setAElement(0, 9, 1.0, 1, linearSystemData);
  linearSystemData->setAElement(1, 8, $PInductor1$PL, 2, linearSystemData);
  linearSystemData->setAElement(1, 9, -1.0, 3, linearSystemData);
  linearSystemData->setAElement(2, 1, 1.0, 4, linearSystemData);
  linearSystemData->setAElement(2, 7, 1.0, 5, linearSystemData);
  linearSystemData->setAElement(2, 8, 1.0, 6, linearSystemData);
  linearSystemData->setAElement(3, 6, -1.0, 7, linearSystemData);
  linearSystemData->setAElement(3, 7, $PInductor3$PL, 8, linearSystemData);
  linearSystemData->setAElement(4, 5, -1.0, 9, linearSystemData);
  linearSystemData->setAElement(4, 6, 1.0, 10, linearSystemData);
  linearSystemData->setAElement(5, 4, 1.0, 11, linearSystemData);
  linearSystemData->setAElement(5, 5, -1.0, 12, linearSystemData);
  linearSystemData->setAElement(6, 3, -1.0, 13, linearSystemData);
  linearSystemData->setAElement(6, 4, 1.0, 14, linearSystemData);
  linearSystemData->setAElement(7, 2, 1.0, 15, linearSystemData);
  linearSystemData->setAElement(7, 3, -1.0, 16, linearSystemData);
  linearSystemData->setAElement(8, 1, $PInductor2$PL, 17, linearSystemData);
  linearSystemData->setAElement(8, 2, -1.0, 18, linearSystemData);
  linearSystemData->setAElement(9, 0, -1.0, 19, linearSystemData);
  linearSystemData->setAElement(9, 4, 1.0, 20, linearSystemData);
}
void setLinearVectorb153(void *inData, void *systemData)
{
  DATA* data = (DATA*) inData;
  LINEAR_SYSTEM_DATA* linearSystemData = (LINEAR_SYSTEM_DATA*) systemData;
  linearSystemData->b[0] =  (-$PIdealDiode1$Pp$Pv);
  linearSystemData->b[1] =  0.0;
  linearSystemData->b[2] =  0.0;
  linearSystemData->b[3] =  0.0;
  linearSystemData->b[4] =  (-$PIdealDiode3$Pp$Pv);
  linearSystemData->b[5] =  (-$PSineVoltage3$Pv);
  linearSystemData->b[6] =  (-$PSineVoltage2$Pv);
  linearSystemData->b[7] =  (-$PIdealDiode2$Pp$Pv);
  linearSystemData->b[8] =  0.0;
  linearSystemData->b[9] =  (-$PSineVoltage1$Pv);

}
/* jacobians linear systems */

/* funtion initialize linear systems */
void initialLinearSystem(LINEAR_SYSTEM_DATA* linearSystemData)
{
  /* initial linear systems */
  linearSystemData[0].equationIndex = 96;
  linearSystemData[0].size = 10;
  linearSystemData[0].nnz = 21;
  linearSystemData[0].setA = setLinearMatrixA96;
  linearSystemData[0].setb = setLinearVectorb96;
  /* inline linear systems */
  /* parameter linear systems */
  /* model linear systems */
  linearSystemData[1].equationIndex = 153;
  linearSystemData[1].size = 10;
  linearSystemData[1].nnz = 21;
  linearSystemData[1].setA = setLinearMatrixA153;
  linearSystemData[1].setb = setLinearVectorb153;
  /* jacobians linear systems */
}

/* funtion initialize state sets */
void initializeStateSets(STATE_SET_DATA* statesetData, DATA *data)
{
}

int input_function(DATA *data)
{
  return 0;
}

int output_function(DATA *data)
{
  data->simulationInfo.outputVars[0] = $PuAC$lB1$rB;
  data->simulationInfo.outputVars[1] = $PuAC$lB2$rB;
  data->simulationInfo.outputVars[2] = $PuAC$lB3$rB;
  data->simulationInfo.outputVars[3] = $PiAC$lB1$rB;
  data->simulationInfo.outputVars[4] = $PiAC$lB2$rB;
  data->simulationInfo.outputVars[5] = $PiAC$lB3$rB;
  data->simulationInfo.outputVars[6] = $PLosses;
  data->simulationInfo.outputVars[7] = $PuDC;
  return 0;
}

/* Initializes the raw time events of the simulation using the now
   calcualted parameters. */
void function_initSample(DATA *data)
{
  long i=0;

}

int function_storeDelayed(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}

int updateBoundStartValues(DATA *data)
{

  
  INFO(LOG_INIT, "updating start-values");
  INDENT(LOG_INIT);
  RELEASE(LOG_INIT);
  
  return 0;
}

const char *initialResidualDescription[] =
{
  "Capacitor1.v + -0.7071067811865476 * VAC", 
  "Capacitor2.v + -0.7071067811865476 * VAC", 
};

int initial_residual(DATA *data, double *initialResiduals)
{
  int i = 0;
  state mem_state;
  
  mem_state = get_memory_state();
  INFO(LOG_RES_INIT, "updating initial residuals");
  INDENT(LOG_RES_INIT);
  initialResiduals[i++] = ($PCapacitor1$Pv + (-0.7071067811865476 * $PVAC));
  INFO3(LOG_RES_INIT, "[%d]: %s = %g", i, initialResidualDescription[i-1], initialResiduals[i-1]);
  initialResiduals[i++] = ($PCapacitor2$Pv + (-0.7071067811865476 * $PVAC));
  INFO3(LOG_RES_INIT, "[%d]: %s = %g", i, initialResidualDescription[i-1], initialResiduals[i-1]);
  RELEASE(LOG_RES_INIT);
  restore_memory_state(mem_state);
  
  return 0;
}

/*
 equation index: 1
 type: SIMPLE_ASSIGN
 Constant1._k = IDC
 */
static void eqFunction_1(DATA *data)
{
  $PConstant1$Pk = $PIDC;
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 Capacitor2._C = 2.0 * CDC
 */
static void eqFunction_2(DATA *data)
{
  $PCapacitor2$PC = (2.0 * $PCDC);
}
/*
 equation index: 3
 type: SIMPLE_ASSIGN
 Capacitor1._C = 2.0 * CDC
 */
static void eqFunction_3(DATA *data)
{
  $PCapacitor1$PC = (2.0 * $PCDC);
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 IdealDiode6._Vknee = Vknee
 */
static void eqFunction_4(DATA *data)
{
  $PIdealDiode6$PVknee = $PVknee;
}
/*
 equation index: 5
 type: SIMPLE_ASSIGN
 IdealDiode6._Goff = Goff
 */
static void eqFunction_5(DATA *data)
{
  $PIdealDiode6$PGoff = $PGoff;
}
/*
 equation index: 6
 type: SIMPLE_ASSIGN
 IdealDiode6._Ron = Ron
 */
static void eqFunction_6(DATA *data)
{
  $PIdealDiode6$PRon = $PRon;
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 IdealDiode5._Vknee = Vknee
 */
static void eqFunction_7(DATA *data)
{
  $PIdealDiode5$PVknee = $PVknee;
}
/*
 equation index: 8
 type: SIMPLE_ASSIGN
 IdealDiode5._Goff = Goff
 */
static void eqFunction_8(DATA *data)
{
  $PIdealDiode5$PGoff = $PGoff;
}
/*
 equation index: 9
 type: SIMPLE_ASSIGN
 IdealDiode5._Ron = Ron
 */
static void eqFunction_9(DATA *data)
{
  $PIdealDiode5$PRon = $PRon;
}
/*
 equation index: 10
 type: SIMPLE_ASSIGN
 IdealDiode4._Vknee = Vknee
 */
static void eqFunction_10(DATA *data)
{
  $PIdealDiode4$PVknee = $PVknee;
}
/*
 equation index: 11
 type: SIMPLE_ASSIGN
 IdealDiode4._Goff = Goff
 */
static void eqFunction_11(DATA *data)
{
  $PIdealDiode4$PGoff = $PGoff;
}
/*
 equation index: 12
 type: SIMPLE_ASSIGN
 IdealDiode4._Ron = Ron
 */
static void eqFunction_12(DATA *data)
{
  $PIdealDiode4$PRon = $PRon;
}
/*
 equation index: 13
 type: SIMPLE_ASSIGN
 IdealDiode3._Vknee = Vknee
 */
static void eqFunction_13(DATA *data)
{
  $PIdealDiode3$PVknee = $PVknee;
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 IdealDiode3._Goff = Goff
 */
static void eqFunction_14(DATA *data)
{
  $PIdealDiode3$PGoff = $PGoff;
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 IdealDiode3._Ron = Ron
 */
static void eqFunction_15(DATA *data)
{
  $PIdealDiode3$PRon = $PRon;
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 IdealDiode2._Vknee = Vknee
 */
static void eqFunction_16(DATA *data)
{
  $PIdealDiode2$PVknee = $PVknee;
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 IdealDiode2._Goff = Goff
 */
static void eqFunction_17(DATA *data)
{
  $PIdealDiode2$PGoff = $PGoff;
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 IdealDiode2._Ron = Ron
 */
static void eqFunction_18(DATA *data)
{
  $PIdealDiode2$PRon = $PRon;
}
/*
 equation index: 19
 type: SIMPLE_ASSIGN
 IdealDiode1._Vknee = Vknee
 */
static void eqFunction_19(DATA *data)
{
  $PIdealDiode1$PVknee = $PVknee;
}
/*
 equation index: 20
 type: SIMPLE_ASSIGN
 IdealDiode1._Goff = Goff
 */
static void eqFunction_20(DATA *data)
{
  $PIdealDiode1$PGoff = $PGoff;
}
/*
 equation index: 21
 type: SIMPLE_ASSIGN
 IdealDiode1._Ron = Ron
 */
static void eqFunction_21(DATA *data)
{
  $PIdealDiode1$PRon = $PRon;
}
/*
 equation index: 22
 type: SIMPLE_ASSIGN
 Inductor3._L = LAC
 */
static void eqFunction_22(DATA *data)
{
  $PInductor3$PL = $PLAC;
}
/*
 equation index: 23
 type: SIMPLE_ASSIGN
 Inductor2._L = LAC
 */
static void eqFunction_23(DATA *data)
{
  $PInductor2$PL = $PLAC;
}
/*
 equation index: 24
 type: SIMPLE_ASSIGN
 Inductor1._L = LAC
 */
static void eqFunction_24(DATA *data)
{
  $PInductor1$PL = $PLAC;
}
/*
 equation index: 25
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._startTime = SineVoltage3.startTime
 */
static void eqFunction_25(DATA *data)
{
  $PSineVoltage3$PsignalSource$PstartTime = $PSineVoltage3$PstartTime;
}
/*
 equation index: 26
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._offset = SineVoltage3.offset
 */
static void eqFunction_26(DATA *data)
{
  $PSineVoltage3$PsignalSource$Poffset = $PSineVoltage3$Poffset;
}
/*
 equation index: 27
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._phase = SineVoltage3.phase
 */
static void eqFunction_27(DATA *data)
{
  $PSineVoltage3$PsignalSource$Pphase = $PSineVoltage3$Pphase;
}
/*
 equation index: 28
 type: SIMPLE_ASSIGN
 SineVoltage3._freqHz = f
 */
static void eqFunction_28(DATA *data)
{
  $PSineVoltage3$PfreqHz = $Pf;
}
/*
 equation index: 29
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._freqHz = SineVoltage3.freqHz
 */
static void eqFunction_29(DATA *data)
{
  $PSineVoltage3$PsignalSource$PfreqHz = $PSineVoltage3$PfreqHz;
}
/*
 equation index: 30
 type: SIMPLE_ASSIGN
 SineVoltage3._V = 0.816496580927726 * VAC
 */
static void eqFunction_30(DATA *data)
{
  $PSineVoltage3$PV = (0.816496580927726 * $PVAC);
}
/*
 equation index: 31
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._amplitude = SineVoltage3.V
 */
static void eqFunction_31(DATA *data)
{
  $PSineVoltage3$PsignalSource$Pamplitude = $PSineVoltage3$PV;
}
/*
 equation index: 32
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._startTime = SineVoltage2.startTime
 */
static void eqFunction_32(DATA *data)
{
  $PSineVoltage2$PsignalSource$PstartTime = $PSineVoltage2$PstartTime;
}
/*
 equation index: 33
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._offset = SineVoltage2.offset
 */
static void eqFunction_33(DATA *data)
{
  $PSineVoltage2$PsignalSource$Poffset = $PSineVoltage2$Poffset;
}
/*
 equation index: 34
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._phase = SineVoltage2.phase
 */
static void eqFunction_34(DATA *data)
{
  $PSineVoltage2$PsignalSource$Pphase = $PSineVoltage2$Pphase;
}
/*
 equation index: 35
 type: SIMPLE_ASSIGN
 SineVoltage2._freqHz = f
 */
static void eqFunction_35(DATA *data)
{
  $PSineVoltage2$PfreqHz = $Pf;
}
/*
 equation index: 36
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._freqHz = SineVoltage2.freqHz
 */
static void eqFunction_36(DATA *data)
{
  $PSineVoltage2$PsignalSource$PfreqHz = $PSineVoltage2$PfreqHz;
}
/*
 equation index: 37
 type: SIMPLE_ASSIGN
 SineVoltage2._V = 0.816496580927726 * VAC
 */
static void eqFunction_37(DATA *data)
{
  $PSineVoltage2$PV = (0.816496580927726 * $PVAC);
}
/*
 equation index: 38
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._amplitude = SineVoltage2.V
 */
static void eqFunction_38(DATA *data)
{
  $PSineVoltage2$PsignalSource$Pamplitude = $PSineVoltage2$PV;
}
/*
 equation index: 39
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._startTime = SineVoltage1.startTime
 */
static void eqFunction_39(DATA *data)
{
  $PSineVoltage1$PsignalSource$PstartTime = $PSineVoltage1$PstartTime;
}
/*
 equation index: 40
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._offset = SineVoltage1.offset
 */
static void eqFunction_40(DATA *data)
{
  $PSineVoltage1$PsignalSource$Poffset = $PSineVoltage1$Poffset;
}
/*
 equation index: 41
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._phase = SineVoltage1.phase
 */
static void eqFunction_41(DATA *data)
{
  $PSineVoltage1$PsignalSource$Pphase = $PSineVoltage1$Pphase;
}
/*
 equation index: 42
 type: SIMPLE_ASSIGN
 SineVoltage1._freqHz = f
 */
static void eqFunction_42(DATA *data)
{
  $PSineVoltage1$PfreqHz = $Pf;
}
/*
 equation index: 43
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._freqHz = SineVoltage1.freqHz
 */
static void eqFunction_43(DATA *data)
{
  $PSineVoltage1$PsignalSource$PfreqHz = $PSineVoltage1$PfreqHz;
}
/*
 equation index: 44
 type: SIMPLE_ASSIGN
 SineVoltage1._V = 0.816496580927726 * VAC
 */
static void eqFunction_44(DATA *data)
{
  $PSineVoltage1$PV = (0.816496580927726 * $PVAC);
}
/*
 equation index: 45
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._amplitude = SineVoltage1.V
 */
static void eqFunction_45(DATA *data)
{
  $PSineVoltage1$PsignalSource$Pamplitude = $PSineVoltage1$PV;
}
/*
 equation index: 46
 type: SIMPLE_ASSIGN
 iAC[1] = (-Inductor2.i) - Inductor3.i
 */
static void eqFunction_46(DATA *data)
{
  $PiAC$lB1$rB = ((-$PInductor2$Pi) - $PInductor3$Pi);
}
/*
 equation index: 47
 type: SIMPLE_ASSIGN
 SineVoltage3._v = SineVoltage3.signalSource.offset + (if time < SineVoltage3.signalSource.startTime then 0.0 else SineVoltage3.signalSource.amplitude * sin(6.283185307179586 * SineVoltage3.signalSource.freqHz * (time - SineVoltage3.signalSource.startTime) + SineVoltage3.signalSource.phase))
 */
static void eqFunction_47(DATA *data)
{
  modelica_boolean tmp0;
  modelica_real tmp1;
  modelica_boolean tmp2;
  modelica_real tmp3;
  RELATIONHYSTERESIS(tmp0, time, $PSineVoltage3$PsignalSource$PstartTime, 6, Less);
  tmp2 = (modelica_boolean)tmp0;
  if(tmp2)
  {
    tmp3 = 0.0;
  }
  else
  {
    tmp1 = sin(((6.283185307179586 * ($PSineVoltage3$PsignalSource$PfreqHz * (time - $PSineVoltage3$PsignalSource$PstartTime))) + $PSineVoltage3$PsignalSource$Pphase));
    tmp3 = ($PSineVoltage3$PsignalSource$Pamplitude * tmp1);
  }
  $PSineVoltage3$Pv = ($PSineVoltage3$PsignalSource$Poffset + tmp3);
}
/*
 equation index: 48
 type: SIMPLE_ASSIGN
 SineVoltage2._v = SineVoltage2.signalSource.offset + (if time < SineVoltage2.signalSource.startTime then 0.0 else SineVoltage2.signalSource.amplitude * sin(6.283185307179586 * SineVoltage2.signalSource.freqHz * (time - SineVoltage2.signalSource.startTime) + SineVoltage2.signalSource.phase))
 */
static void eqFunction_48(DATA *data)
{
  modelica_boolean tmp4;
  modelica_real tmp5;
  modelica_boolean tmp6;
  modelica_real tmp7;
  RELATIONHYSTERESIS(tmp4, time, $PSineVoltage2$PsignalSource$PstartTime, 7, Less);
  tmp6 = (modelica_boolean)tmp4;
  if(tmp6)
  {
    tmp7 = 0.0;
  }
  else
  {
    tmp5 = sin(((6.283185307179586 * ($PSineVoltage2$PsignalSource$PfreqHz * (time - $PSineVoltage2$PsignalSource$PstartTime))) + $PSineVoltage2$PsignalSource$Pphase));
    tmp7 = ($PSineVoltage2$PsignalSource$Pamplitude * tmp5);
  }
  $PSineVoltage2$Pv = ($PSineVoltage2$PsignalSource$Poffset + tmp7);
}
/*
 equation index: 49
 type: SIMPLE_ASSIGN
 SineVoltage1._v = SineVoltage1.signalSource.offset + (if time < SineVoltage1.signalSource.startTime then 0.0 else SineVoltage1.signalSource.amplitude * sin(6.283185307179586 * SineVoltage1.signalSource.freqHz * (time - SineVoltage1.signalSource.startTime) + SineVoltage1.signalSource.phase))
 */
static void eqFunction_49(DATA *data)
{
  modelica_boolean tmp8;
  modelica_real tmp9;
  modelica_boolean tmp10;
  modelica_real tmp11;
  RELATIONHYSTERESIS(tmp8, time, $PSineVoltage1$PsignalSource$PstartTime, 8, Less);
  tmp10 = (modelica_boolean)tmp8;
  if(tmp10)
  {
    tmp11 = 0.0;
  }
  else
  {
    tmp9 = sin(((6.283185307179586 * ($PSineVoltage1$PsignalSource$PfreqHz * (time - $PSineVoltage1$PsignalSource$PstartTime))) + $PSineVoltage1$PsignalSource$Pphase));
    tmp11 = ($PSineVoltage1$PsignalSource$Pamplitude * tmp9);
  }
  $PSineVoltage1$Pv = ($PSineVoltage1$PsignalSource$Poffset + tmp11);
}
/*
 equation index: 50
 type: SIMPLE_ASSIGN
 Capacitor2._v = 0.7071067811865476 * VAC
 */
static void eqFunction_50(DATA *data)
{
  $PCapacitor2$Pv = (0.7071067811865476 * $PVAC);
}
/*
 equation index: 51
 type: SIMPLE_ASSIGN
 Capacitor1._v = 0.7071067811865476 * VAC
 */
static void eqFunction_51(DATA *data)
{
  $PCapacitor1$Pv = (0.7071067811865476 * $PVAC);
}
/*
 equation index: 52
 type: SIMPLE_ASSIGN
 SignalCurrent1._v = Capacitor1.v + Capacitor2.v
 */
static void eqFunction_52(DATA *data)
{
  $PSignalCurrent1$Pv = ($PCapacitor1$Pv + $PCapacitor2$Pv);
}
/*
 equation index: 62
 indexNonlinear: 0
 type: NONLINEAR
 
 vars: {IdealDiode4._s, IdealDiode1._s}
 eqns: {53, 54, 55, 56, 57, 58, 59, 61, 60}
 */
static void eqFunction_62(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,62).profileBlockIndex);
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,62).profileBlockIndex,-1);
  #endif
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[0].nlsx[0] = $PIdealDiode4$Ps;
  data->simulationInfo.nonlinearSystemData[0].nlsxOld[0] = _$PIdealDiode4$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[0].nlsxExtrapolation[0] = extraPolate(data, _$PIdealDiode4$Ps(1) /*old*/, _$PIdealDiode4$Ps(2) /*old2*/);
  data->simulationInfo.nonlinearSystemData[0].nlsx[1] = $PIdealDiode1$Ps;
  data->simulationInfo.nonlinearSystemData[0].nlsxOld[1] = _$PIdealDiode1$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[0].nlsxExtrapolation[1] = extraPolate(data, _$PIdealDiode1$Ps(1) /*old*/, _$PIdealDiode1$Ps(2) /*old2*/);
  solve_nonlinear_system(data, 0);
  /* write solution */
  $PIdealDiode4$Ps = data->simulationInfo.nonlinearSystemData[0].nlsx[0];
  $PIdealDiode1$Ps = data->simulationInfo.nonlinearSystemData[0].nlsx[1];
  /* update inner equations */
  eqFunction_53(data);
  eqFunction_54(data);
  eqFunction_55(data);
  eqFunction_56(data);
  eqFunction_57(data);
  eqFunction_58(data);
  eqFunction_59(data);
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,62).profileBlockIndex);
  #endif
}
/*
 equation index: 63
 type: SIMPLE_ASSIGN
 IdealDiode1._LossPower = IdealDiode1.v * IdealDiode1.i
 */
static void eqFunction_63(DATA *data)
{
  $PIdealDiode1$PLossPower = ($PIdealDiode1$Pv * $PIdealDiode1$Pi);
}
/*
 equation index: 64
 type: SIMPLE_ASSIGN
 IdealDiode4._LossPower = IdealDiode4.v * IdealDiode4.i
 */
static void eqFunction_64(DATA *data)
{
  $PIdealDiode4$PLossPower = ($PIdealDiode4$Pv * $PIdealDiode4$Pi);
}
/*
 equation index: 74
 indexNonlinear: 1
 type: NONLINEAR
 
 vars: {IdealDiode5._s, IdealDiode2._s}
 eqns: {65, 66, 67, 68, 69, 70, 71, 73, 72}
 */
static void eqFunction_74(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,74).profileBlockIndex);
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,74).profileBlockIndex,-1);
  #endif
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[1].nlsx[0] = $PIdealDiode5$Ps;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[0] = _$PIdealDiode5$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[0] = extraPolate(data, _$PIdealDiode5$Ps(1) /*old*/, _$PIdealDiode5$Ps(2) /*old2*/);
  data->simulationInfo.nonlinearSystemData[1].nlsx[1] = $PIdealDiode2$Ps;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[1] = _$PIdealDiode2$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[1] = extraPolate(data, _$PIdealDiode2$Ps(1) /*old*/, _$PIdealDiode2$Ps(2) /*old2*/);
  solve_nonlinear_system(data, 1);
  /* write solution */
  $PIdealDiode5$Ps = data->simulationInfo.nonlinearSystemData[1].nlsx[0];
  $PIdealDiode2$Ps = data->simulationInfo.nonlinearSystemData[1].nlsx[1];
  /* update inner equations */
  eqFunction_65(data);
  eqFunction_66(data);
  eqFunction_67(data);
  eqFunction_68(data);
  eqFunction_69(data);
  eqFunction_70(data);
  eqFunction_71(data);
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,74).profileBlockIndex);
  #endif
}
/*
 equation index: 75
 type: SIMPLE_ASSIGN
 IdealDiode2._LossPower = IdealDiode2.v * IdealDiode2.i
 */
static void eqFunction_75(DATA *data)
{
  $PIdealDiode2$PLossPower = ($PIdealDiode2$Pv * $PIdealDiode2$Pi);
}
/*
 equation index: 76
 type: SIMPLE_ASSIGN
 IdealDiode5._LossPower = IdealDiode5.v * IdealDiode5.i
 */
static void eqFunction_76(DATA *data)
{
  $PIdealDiode5$PLossPower = ($PIdealDiode5$Pv * $PIdealDiode5$Pi);
}
/*
 equation index: 77
 type: SIMPLE_ASSIGN
 uAC[1] = IdealDiode1.p.v - IdealDiode2.p.v
 */
static void eqFunction_77(DATA *data)
{
  $PuAC$lB1$rB = ($PIdealDiode1$Pp$Pv - $PIdealDiode2$Pp$Pv);
}
/*
 equation index: 87
 indexNonlinear: 2
 type: NONLINEAR
 
 vars: {IdealDiode6._s, IdealDiode3._s}
 eqns: {78, 79, 80, 81, 82, 83, 84, 86, 85}
 */
static void eqFunction_87(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,87).profileBlockIndex);
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,87).profileBlockIndex,-1);
  #endif
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[2].nlsx[0] = $PIdealDiode6$Ps;
  data->simulationInfo.nonlinearSystemData[2].nlsxOld[0] = _$PIdealDiode6$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[2].nlsxExtrapolation[0] = extraPolate(data, _$PIdealDiode6$Ps(1) /*old*/, _$PIdealDiode6$Ps(2) /*old2*/);
  data->simulationInfo.nonlinearSystemData[2].nlsx[1] = $PIdealDiode3$Ps;
  data->simulationInfo.nonlinearSystemData[2].nlsxOld[1] = _$PIdealDiode3$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[2].nlsxExtrapolation[1] = extraPolate(data, _$PIdealDiode3$Ps(1) /*old*/, _$PIdealDiode3$Ps(2) /*old2*/);
  solve_nonlinear_system(data, 2);
  /* write solution */
  $PIdealDiode6$Ps = data->simulationInfo.nonlinearSystemData[2].nlsx[0];
  $PIdealDiode3$Ps = data->simulationInfo.nonlinearSystemData[2].nlsx[1];
  /* update inner equations */
  eqFunction_78(data);
  eqFunction_79(data);
  eqFunction_80(data);
  eqFunction_81(data);
  eqFunction_82(data);
  eqFunction_83(data);
  eqFunction_84(data);
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,87).profileBlockIndex);
  #endif
}
/*
 equation index: 88
 type: SIMPLE_ASSIGN
 Capacitor1._i = IdealDiode1.i - (-IdealDiode3.i) - IdealDiode2.i - Constant1.k
 */
static void eqFunction_88(DATA *data)
{
  $PCapacitor1$Pi = (($PIdealDiode1$Pi - ((-$PIdealDiode3$Pi) - $PIdealDiode2$Pi)) - $PConstant1$Pk);
}
/*
 equation index: 89
 type: SIMPLE_ASSIGN
 der(Capacitor1._v) = DIVISION(Capacitor1.i, Capacitor1.C, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_89(DATA *data)
{
  modelica_real tmp18;
  tmp18 = DIVISION($PCapacitor1$Pi, $PCapacitor1$PC, _OMC_LIT3);
  $P$DER$PCapacitor1$Pv = tmp18;
}
/*
 equation index: 90
 type: SIMPLE_ASSIGN
 IdealDiode3._LossPower = IdealDiode3.v * IdealDiode3.i
 */
static void eqFunction_90(DATA *data)
{
  $PIdealDiode3$PLossPower = ($PIdealDiode3$Pv * $PIdealDiode3$Pi);
}
/*
 equation index: 91
 type: SIMPLE_ASSIGN
 Capacitor2._i = IdealDiode4.i + IdealDiode5.i + IdealDiode6.i - Constant1.k
 */
static void eqFunction_91(DATA *data)
{
  $PCapacitor2$Pi = ($PIdealDiode4$Pi + ($PIdealDiode5$Pi + ($PIdealDiode6$Pi - $PConstant1$Pk)));
}
/*
 equation index: 92
 type: SIMPLE_ASSIGN
 Ground1._p._i = Capacitor1.i - Capacitor2.i
 */
static void eqFunction_92(DATA *data)
{
  $PGround1$Pp$Pi = ($PCapacitor1$Pi - $PCapacitor2$Pi);
}
/*
 equation index: 93
 type: SIMPLE_ASSIGN
 der(Capacitor2._v) = DIVISION(Capacitor2.i, Capacitor2.C, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_93(DATA *data)
{
  modelica_real tmp19;
  tmp19 = DIVISION($PCapacitor2$Pi, $PCapacitor2$PC, _OMC_LIT2);
  $P$DER$PCapacitor2$Pv = tmp19;
}
/*
 equation index: 94
 type: SIMPLE_ASSIGN
 IdealDiode6._LossPower = IdealDiode6.v * IdealDiode6.i
 */
static void eqFunction_94(DATA *data)
{
  $PIdealDiode6$PLossPower = ($PIdealDiode6$Pv * $PIdealDiode6$Pi);
}
/*
 equation index: 95
 type: SIMPLE_ASSIGN
 Losses = IdealDiode1.LossPower + IdealDiode2.LossPower + IdealDiode3.LossPower + IdealDiode4.LossPower + IdealDiode5.LossPower + IdealDiode6.LossPower
 */
static void eqFunction_95(DATA *data)
{
  $PLosses = ($PIdealDiode1$PLossPower + ($PIdealDiode2$PLossPower + ($PIdealDiode3$PLossPower + ($PIdealDiode4$PLossPower + ($PIdealDiode5$PLossPower + $PIdealDiode6$PLossPower)))));
}
/*
 equation index: 96
 type: LINEAR
 
 <var>der(Inductor2._i)</var>
 <var>Inductor2._v</var>
 <var>Inductor2._p._v</var>
 <var>Inductor3._v</var>
 <var>der(Inductor3._i)</var>
 <var>der(Inductor1._i)</var>
 <var>Inductor1._v</var>
 <var>Inductor1._p._v</var>
 <var>SineVoltage1._n._v</var>
 <var>Inductor3._p._v</var>
 <row>
   <cell>-IdealDiode3.p.v</cell>
   <cell>-SineVoltage3.v</cell>
   <cell>-SineVoltage1.v</cell>
   <cell>-IdealDiode1.p.v</cell>
   <cell>0.0</cell>
   <cell>0.0</cell>
   <cell>0.0</cell>
   <cell>-SineVoltage2.v</cell>
   <cell>-IdealDiode2.p.v</cell>
   <cell>0.0</cell>
 </row>
 <matrix>
   <cell row="0" col="3">
     <residual>1.0</residual>
   </cell><cell row="0" col="9">
     <residual>-1.0</residual>
   </cell><cell row="1" col="8">
     <residual>1.0</residual>
   </cell><cell row="1" col="9">
     <residual>-1.0</residual>
   </cell><cell row="2" col="7">
     <residual>-1.0</residual>
   </cell><cell row="2" col="8">
     <residual>1.0</residual>
   </cell><cell row="3" col="6">
     <residual>1.0</residual>
   </cell><cell row="3" col="7">
     <residual>-1.0</residual>
   </cell><cell row="4" col="5">
     <residual>Inductor1.L</residual>
   </cell><cell row="4" col="6">
     <residual>-1.0</residual>
   </cell><cell row="5" col="0">
     <residual>1.0</residual>
   </cell><cell row="5" col="4">
     <residual>1.0</residual>
   </cell><cell row="5" col="5">
     <residual>1.0</residual>
   </cell><cell row="6" col="3">
     <residual>-1.0</residual>
   </cell><cell row="6" col="4">
     <residual>Inductor3.L</residual>
   </cell><cell row="7" col="2">
     <residual>-1.0</residual>
   </cell><cell row="7" col="8">
     <residual>1.0</residual>
   </cell><cell row="8" col="1">
     <residual>1.0</residual>
   </cell><cell row="8" col="2">
     <residual>-1.0</residual>
   </cell><cell row="9" col="0">
     <residual>Inductor2.L</residual>
   </cell><cell row="9" col="1">
     <residual>-1.0</residual>
   </cell>
 </matrix>
 */
static void eqFunction_96(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,96).profileBlockIndex);
  #endif
  /* Linear equation system */
  solve_linear_system(data, 0);
  $P$DER$PInductor2$Pi = data->simulationInfo.linearSystemData[0].x[0];
  $PInductor2$Pv = data->simulationInfo.linearSystemData[0].x[1];
  $PInductor2$Pp$Pv = data->simulationInfo.linearSystemData[0].x[2];
  $PInductor3$Pv = data->simulationInfo.linearSystemData[0].x[3];
  $P$DER$PInductor3$Pi = data->simulationInfo.linearSystemData[0].x[4];
  $P$DER$PInductor1$Pi = data->simulationInfo.linearSystemData[0].x[5];
  $PInductor1$Pv = data->simulationInfo.linearSystemData[0].x[6];
  $PInductor1$Pp$Pv = data->simulationInfo.linearSystemData[0].x[7];
  $PSineVoltage1$Pn$Pv = data->simulationInfo.linearSystemData[0].x[8];
  $PInductor3$Pp$Pv = data->simulationInfo.linearSystemData[0].x[9];
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,96).profileBlockIndex);
  #endif
}
/*
 equation index: 97
 type: SIMPLE_ASSIGN
 uAC[3] = IdealDiode3.p.v - IdealDiode1.p.v
 */
static void eqFunction_97(DATA *data)
{
  $PuAC$lB3$rB = ($PIdealDiode3$Pp$Pv - $PIdealDiode1$Pp$Pv);
}
/*
 equation index: 98
 type: SIMPLE_ASSIGN
 uAC[2] = IdealDiode2.p.v - IdealDiode3.p.v
 */
static void eqFunction_98(DATA *data)
{
  $PuAC$lB2$rB = ($PIdealDiode2$Pp$Pv - $PIdealDiode3$Pp$Pv);
}
/*
 equation index: 99
 type: SIMPLE_ASSIGN
 uDC = Capacitor1.v + Capacitor2.v
 */
static void eqFunction_99(DATA *data)
{
  $PuDC = ($PCapacitor1$Pv + $PCapacitor2$Pv);
}
/*
 equation index: 100
 type: SIMPLE_ASSIGN
 iAC[2] = Inductor2.i
 */
static void eqFunction_100(DATA *data)
{
  $PiAC$lB2$rB = $PInductor2$Pi;
}
/*
 equation index: 101
 type: SIMPLE_ASSIGN
 iAC[3] = Inductor3.i
 */
static void eqFunction_101(DATA *data)
{
  $PiAC$lB3$rB = $PInductor3$Pi;
}
/*
 equation index: 102
 type: SIMPLE_ASSIGN
 Ground1._p._v = 0.0
 */
static void eqFunction_102(DATA *data)
{
  $PGround1$Pp$Pv = 0.0;
}
const int useSymbolicInitialization = 1; /* true */
const int useHomotopy = 0; /* false */
int functionInitialEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  data->simulationInfo.discreteCall = 1;
  eqFunction_1(data);
  restore_memory_state(mem_state);
  eqFunction_2(data);
  restore_memory_state(mem_state);
  eqFunction_3(data);
  restore_memory_state(mem_state);
  eqFunction_4(data);
  restore_memory_state(mem_state);
  eqFunction_5(data);
  restore_memory_state(mem_state);
  eqFunction_6(data);
  restore_memory_state(mem_state);
  eqFunction_7(data);
  restore_memory_state(mem_state);
  eqFunction_8(data);
  restore_memory_state(mem_state);
  eqFunction_9(data);
  restore_memory_state(mem_state);
  eqFunction_10(data);
  restore_memory_state(mem_state);
  eqFunction_11(data);
  restore_memory_state(mem_state);
  eqFunction_12(data);
  restore_memory_state(mem_state);
  eqFunction_13(data);
  restore_memory_state(mem_state);
  eqFunction_14(data);
  restore_memory_state(mem_state);
  eqFunction_15(data);
  restore_memory_state(mem_state);
  eqFunction_16(data);
  restore_memory_state(mem_state);
  eqFunction_17(data);
  restore_memory_state(mem_state);
  eqFunction_18(data);
  restore_memory_state(mem_state);
  eqFunction_19(data);
  restore_memory_state(mem_state);
  eqFunction_20(data);
  restore_memory_state(mem_state);
  eqFunction_21(data);
  restore_memory_state(mem_state);
  eqFunction_22(data);
  restore_memory_state(mem_state);
  eqFunction_23(data);
  restore_memory_state(mem_state);
  eqFunction_24(data);
  restore_memory_state(mem_state);
  eqFunction_25(data);
  restore_memory_state(mem_state);
  eqFunction_26(data);
  restore_memory_state(mem_state);
  eqFunction_27(data);
  restore_memory_state(mem_state);
  eqFunction_28(data);
  restore_memory_state(mem_state);
  eqFunction_29(data);
  restore_memory_state(mem_state);
  eqFunction_30(data);
  restore_memory_state(mem_state);
  eqFunction_31(data);
  restore_memory_state(mem_state);
  eqFunction_32(data);
  restore_memory_state(mem_state);
  eqFunction_33(data);
  restore_memory_state(mem_state);
  eqFunction_34(data);
  restore_memory_state(mem_state);
  eqFunction_35(data);
  restore_memory_state(mem_state);
  eqFunction_36(data);
  restore_memory_state(mem_state);
  eqFunction_37(data);
  restore_memory_state(mem_state);
  eqFunction_38(data);
  restore_memory_state(mem_state);
  eqFunction_39(data);
  restore_memory_state(mem_state);
  eqFunction_40(data);
  restore_memory_state(mem_state);
  eqFunction_41(data);
  restore_memory_state(mem_state);
  eqFunction_42(data);
  restore_memory_state(mem_state);
  eqFunction_43(data);
  restore_memory_state(mem_state);
  eqFunction_44(data);
  restore_memory_state(mem_state);
  eqFunction_45(data);
  restore_memory_state(mem_state);
  eqFunction_46(data);
  restore_memory_state(mem_state);
  eqFunction_47(data);
  restore_memory_state(mem_state);
  eqFunction_48(data);
  restore_memory_state(mem_state);
  eqFunction_49(data);
  restore_memory_state(mem_state);
  eqFunction_50(data);
  restore_memory_state(mem_state);
  eqFunction_51(data);
  restore_memory_state(mem_state);
  eqFunction_52(data);
  restore_memory_state(mem_state);
  eqFunction_62(data);
  restore_memory_state(mem_state);
  eqFunction_63(data);
  restore_memory_state(mem_state);
  eqFunction_64(data);
  restore_memory_state(mem_state);
  eqFunction_74(data);
  restore_memory_state(mem_state);
  eqFunction_75(data);
  restore_memory_state(mem_state);
  eqFunction_76(data);
  restore_memory_state(mem_state);
  eqFunction_77(data);
  restore_memory_state(mem_state);
  eqFunction_87(data);
  restore_memory_state(mem_state);
  eqFunction_88(data);
  restore_memory_state(mem_state);
  eqFunction_89(data);
  restore_memory_state(mem_state);
  eqFunction_90(data);
  restore_memory_state(mem_state);
  eqFunction_91(data);
  restore_memory_state(mem_state);
  eqFunction_92(data);
  restore_memory_state(mem_state);
  eqFunction_93(data);
  restore_memory_state(mem_state);
  eqFunction_94(data);
  restore_memory_state(mem_state);
  eqFunction_95(data);
  restore_memory_state(mem_state);
  eqFunction_96(data);
  restore_memory_state(mem_state);
  eqFunction_97(data);
  restore_memory_state(mem_state);
  eqFunction_98(data);
  restore_memory_state(mem_state);
  eqFunction_99(data);
  restore_memory_state(mem_state);
  eqFunction_100(data);
  restore_memory_state(mem_state);
  eqFunction_101(data);
  restore_memory_state(mem_state);
  eqFunction_102(data);
  restore_memory_state(mem_state);
  data->simulationInfo.discreteCall = 0;
  
  return 0;
}

int functionInlineEquations(DATA *data)
{
  state mem_state;
  
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 159
 type: SIMPLE_ASSIGN
 Ground1._p._v = 0.0
 */
static void eqFunction_159(DATA *data)
{
  $PGround1$Pp$Pv = 0.0;
}
/*
 equation index: 160
 type: SIMPLE_ASSIGN
 SineVoltage1._V = 0.816496580927726 * VAC
 */
static void eqFunction_160(DATA *data)
{
  $PSineVoltage1$PV = (0.816496580927726 * $PVAC);
}
/*
 equation index: 161
 type: SIMPLE_ASSIGN
 SineVoltage1._freqHz = f
 */
static void eqFunction_161(DATA *data)
{
  $PSineVoltage1$PfreqHz = $Pf;
}
/*
 equation index: 162
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._amplitude = SineVoltage1.V
 */
static void eqFunction_162(DATA *data)
{
  $PSineVoltage1$PsignalSource$Pamplitude = $PSineVoltage1$PV;
}
/*
 equation index: 163
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._freqHz = SineVoltage1.freqHz
 */
static void eqFunction_163(DATA *data)
{
  $PSineVoltage1$PsignalSource$PfreqHz = $PSineVoltage1$PfreqHz;
}
/*
 equation index: 164
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._phase = SineVoltage1.phase
 */
static void eqFunction_164(DATA *data)
{
  $PSineVoltage1$PsignalSource$Pphase = $PSineVoltage1$Pphase;
}
/*
 equation index: 165
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._offset = SineVoltage1.offset
 */
static void eqFunction_165(DATA *data)
{
  $PSineVoltage1$PsignalSource$Poffset = $PSineVoltage1$Poffset;
}
/*
 equation index: 166
 type: SIMPLE_ASSIGN
 SineVoltage1._signalSource._startTime = SineVoltage1.startTime
 */
static void eqFunction_166(DATA *data)
{
  $PSineVoltage1$PsignalSource$PstartTime = $PSineVoltage1$PstartTime;
}
/*
 equation index: 167
 type: SIMPLE_ASSIGN
 SineVoltage2._V = 0.816496580927726 * VAC
 */
static void eqFunction_167(DATA *data)
{
  $PSineVoltage2$PV = (0.816496580927726 * $PVAC);
}
/*
 equation index: 168
 type: SIMPLE_ASSIGN
 SineVoltage2._freqHz = f
 */
static void eqFunction_168(DATA *data)
{
  $PSineVoltage2$PfreqHz = $Pf;
}
/*
 equation index: 169
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._amplitude = SineVoltage2.V
 */
static void eqFunction_169(DATA *data)
{
  $PSineVoltage2$PsignalSource$Pamplitude = $PSineVoltage2$PV;
}
/*
 equation index: 170
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._freqHz = SineVoltage2.freqHz
 */
static void eqFunction_170(DATA *data)
{
  $PSineVoltage2$PsignalSource$PfreqHz = $PSineVoltage2$PfreqHz;
}
/*
 equation index: 171
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._phase = SineVoltage2.phase
 */
static void eqFunction_171(DATA *data)
{
  $PSineVoltage2$PsignalSource$Pphase = $PSineVoltage2$Pphase;
}
/*
 equation index: 172
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._offset = SineVoltage2.offset
 */
static void eqFunction_172(DATA *data)
{
  $PSineVoltage2$PsignalSource$Poffset = $PSineVoltage2$Poffset;
}
/*
 equation index: 173
 type: SIMPLE_ASSIGN
 SineVoltage2._signalSource._startTime = SineVoltage2.startTime
 */
static void eqFunction_173(DATA *data)
{
  $PSineVoltage2$PsignalSource$PstartTime = $PSineVoltage2$PstartTime;
}
/*
 equation index: 174
 type: SIMPLE_ASSIGN
 SineVoltage3._V = 0.816496580927726 * VAC
 */
static void eqFunction_174(DATA *data)
{
  $PSineVoltage3$PV = (0.816496580927726 * $PVAC);
}
/*
 equation index: 175
 type: SIMPLE_ASSIGN
 SineVoltage3._freqHz = f
 */
static void eqFunction_175(DATA *data)
{
  $PSineVoltage3$PfreqHz = $Pf;
}
/*
 equation index: 176
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._amplitude = SineVoltage3.V
 */
static void eqFunction_176(DATA *data)
{
  $PSineVoltage3$PsignalSource$Pamplitude = $PSineVoltage3$PV;
}
/*
 equation index: 177
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._freqHz = SineVoltage3.freqHz
 */
static void eqFunction_177(DATA *data)
{
  $PSineVoltage3$PsignalSource$PfreqHz = $PSineVoltage3$PfreqHz;
}
/*
 equation index: 178
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._phase = SineVoltage3.phase
 */
static void eqFunction_178(DATA *data)
{
  $PSineVoltage3$PsignalSource$Pphase = $PSineVoltage3$Pphase;
}
/*
 equation index: 179
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._offset = SineVoltage3.offset
 */
static void eqFunction_179(DATA *data)
{
  $PSineVoltage3$PsignalSource$Poffset = $PSineVoltage3$Poffset;
}
/*
 equation index: 180
 type: SIMPLE_ASSIGN
 SineVoltage3._signalSource._startTime = SineVoltage3.startTime
 */
static void eqFunction_180(DATA *data)
{
  $PSineVoltage3$PsignalSource$PstartTime = $PSineVoltage3$PstartTime;
}
/*
 equation index: 181
 type: SIMPLE_ASSIGN
 Inductor1._L = LAC
 */
static void eqFunction_181(DATA *data)
{
  $PInductor1$PL = $PLAC;
}
/*
 equation index: 182
 type: SIMPLE_ASSIGN
 Inductor2._L = LAC
 */
static void eqFunction_182(DATA *data)
{
  $PInductor2$PL = $PLAC;
}
/*
 equation index: 183
 type: SIMPLE_ASSIGN
 Inductor3._L = LAC
 */
static void eqFunction_183(DATA *data)
{
  $PInductor3$PL = $PLAC;
}
/*
 equation index: 184
 type: SIMPLE_ASSIGN
 IdealDiode1._Ron = Ron
 */
static void eqFunction_184(DATA *data)
{
  $PIdealDiode1$PRon = $PRon;
}
/*
 equation index: 185
 type: SIMPLE_ASSIGN
 IdealDiode1._Goff = Goff
 */
static void eqFunction_185(DATA *data)
{
  $PIdealDiode1$PGoff = $PGoff;
}
/*
 equation index: 186
 type: SIMPLE_ASSIGN
 IdealDiode1._Vknee = Vknee
 */
static void eqFunction_186(DATA *data)
{
  $PIdealDiode1$PVknee = $PVknee;
}
/*
 equation index: 187
 type: SIMPLE_ASSIGN
 IdealDiode2._Ron = Ron
 */
static void eqFunction_187(DATA *data)
{
  $PIdealDiode2$PRon = $PRon;
}
/*
 equation index: 188
 type: SIMPLE_ASSIGN
 IdealDiode2._Goff = Goff
 */
static void eqFunction_188(DATA *data)
{
  $PIdealDiode2$PGoff = $PGoff;
}
/*
 equation index: 189
 type: SIMPLE_ASSIGN
 IdealDiode2._Vknee = Vknee
 */
static void eqFunction_189(DATA *data)
{
  $PIdealDiode2$PVknee = $PVknee;
}
/*
 equation index: 190
 type: SIMPLE_ASSIGN
 IdealDiode3._Ron = Ron
 */
static void eqFunction_190(DATA *data)
{
  $PIdealDiode3$PRon = $PRon;
}
/*
 equation index: 191
 type: SIMPLE_ASSIGN
 IdealDiode3._Goff = Goff
 */
static void eqFunction_191(DATA *data)
{
  $PIdealDiode3$PGoff = $PGoff;
}
/*
 equation index: 192
 type: SIMPLE_ASSIGN
 IdealDiode3._Vknee = Vknee
 */
static void eqFunction_192(DATA *data)
{
  $PIdealDiode3$PVknee = $PVknee;
}
/*
 equation index: 193
 type: SIMPLE_ASSIGN
 IdealDiode4._Ron = Ron
 */
static void eqFunction_193(DATA *data)
{
  $PIdealDiode4$PRon = $PRon;
}
/*
 equation index: 194
 type: SIMPLE_ASSIGN
 IdealDiode4._Goff = Goff
 */
static void eqFunction_194(DATA *data)
{
  $PIdealDiode4$PGoff = $PGoff;
}
/*
 equation index: 195
 type: SIMPLE_ASSIGN
 IdealDiode4._Vknee = Vknee
 */
static void eqFunction_195(DATA *data)
{
  $PIdealDiode4$PVknee = $PVknee;
}
/*
 equation index: 196
 type: SIMPLE_ASSIGN
 IdealDiode5._Ron = Ron
 */
static void eqFunction_196(DATA *data)
{
  $PIdealDiode5$PRon = $PRon;
}
/*
 equation index: 197
 type: SIMPLE_ASSIGN
 IdealDiode5._Goff = Goff
 */
static void eqFunction_197(DATA *data)
{
  $PIdealDiode5$PGoff = $PGoff;
}
/*
 equation index: 198
 type: SIMPLE_ASSIGN
 IdealDiode5._Vknee = Vknee
 */
static void eqFunction_198(DATA *data)
{
  $PIdealDiode5$PVknee = $PVknee;
}
/*
 equation index: 199
 type: SIMPLE_ASSIGN
 IdealDiode6._Ron = Ron
 */
static void eqFunction_199(DATA *data)
{
  $PIdealDiode6$PRon = $PRon;
}
/*
 equation index: 200
 type: SIMPLE_ASSIGN
 IdealDiode6._Goff = Goff
 */
static void eqFunction_200(DATA *data)
{
  $PIdealDiode6$PGoff = $PGoff;
}
/*
 equation index: 201
 type: SIMPLE_ASSIGN
 IdealDiode6._Vknee = Vknee
 */
static void eqFunction_201(DATA *data)
{
  $PIdealDiode6$PVknee = $PVknee;
}
/*
 equation index: 202
 type: SIMPLE_ASSIGN
 Capacitor1._C = 2.0 * CDC
 */
static void eqFunction_202(DATA *data)
{
  $PCapacitor1$PC = (2.0 * $PCDC);
}
/*
 equation index: 203
 type: SIMPLE_ASSIGN
 Capacitor2._C = 2.0 * CDC
 */
static void eqFunction_203(DATA *data)
{
  $PCapacitor2$PC = (2.0 * $PCDC);
}
/*
 equation index: 204
 type: SIMPLE_ASSIGN
 Constant1._k = IDC
 */
static void eqFunction_204(DATA *data)
{
  $PConstant1$Pk = $PIDC;
}
/*
 equation index: 205
 type: ALGORITHM
 
   assert(Capacitor2.C >= 0.0, "Variable Capacitor2.C out of [min, max] interval: Capacitor2.C >= 0.0 has value: " + String(Capacitor2.C, "g"));
 */
static void eqFunction_205(DATA *data)
{
  modelica_boolean tmp0;
  modelica_string tmp1;
  modelica_string tmp2;
  static int tmp3 = 0;
  if(!tmp3)
  {
    tmp0 = GreaterEq($PCapacitor2$PC,0.0);
    if(!tmp0)
    {
      tmp1 = modelica_real_to_modelica_string_format($PCapacitor2$PC, "g");
      tmp2 = cat_modelica_string("Variable Capacitor2.C out of [min, max] interval: Capacitor2.C >= 0.0 has value: ",tmp1);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",283,5,283,54,0};
      omc_assert_warning(info, tmp2);
      tmp3 = 1;
    }
  }
}
/*
 equation index: 206
 type: ALGORITHM
 
   assert(Capacitor1.C >= 0.0, "Variable Capacitor1.C out of [min, max] interval: Capacitor1.C >= 0.0 has value: " + String(Capacitor1.C, "g"));
 */
static void eqFunction_206(DATA *data)
{
  modelica_boolean tmp4;
  modelica_string tmp5;
  modelica_string tmp6;
  static int tmp7 = 0;
  if(!tmp7)
  {
    tmp4 = GreaterEq($PCapacitor1$PC,0.0);
    if(!tmp4)
    {
      tmp5 = modelica_real_to_modelica_string_format($PCapacitor1$PC, "g");
      tmp6 = cat_modelica_string("Variable Capacitor1.C out of [min, max] interval: Capacitor1.C >= 0.0 has value: ",tmp5);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Basic.mo",283,5,283,54,0};
      omc_assert_warning(info, tmp6);
      tmp7 = 1;
    }
  }
}
/*
 equation index: 207
 type: ALGORITHM
 
   assert(IdealDiode6.Vknee >= 0.0, "Variable IdealDiode6.Vknee out of [min, max] interval: IdealDiode6.Vknee >= 0.0 has value: " + String(IdealDiode6.Vknee, "g"));
 */
static void eqFunction_207(DATA *data)
{
  modelica_boolean tmp8;
  modelica_string tmp9;
  modelica_string tmp10;
  static int tmp11 = 0;
  if(!tmp11)
  {
    tmp8 = GreaterEq($PIdealDiode6$PVknee,0.0);
    if(!tmp8)
    {
      tmp9 = modelica_real_to_modelica_string_format($PIdealDiode6$PVknee, "g");
      tmp10 = cat_modelica_string("Variable IdealDiode6.Vknee out of [min, max] interval: IdealDiode6.Vknee >= 0.0 has value: ",tmp9);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1043,11,1044,34,0};
      omc_assert_warning(info, tmp10);
      tmp11 = 1;
    }
  }
}
/*
 equation index: 208
 type: ALGORITHM
 
   assert(IdealDiode6.Goff >= 0.0, "Variable IdealDiode6.Goff out of [min, max] interval: IdealDiode6.Goff >= 0.0 has value: " + String(IdealDiode6.Goff, "g"));
 */
static void eqFunction_208(DATA *data)
{
  modelica_boolean tmp12;
  modelica_string tmp13;
  modelica_string tmp14;
  static int tmp15 = 0;
  if(!tmp15)
  {
    tmp12 = GreaterEq($PIdealDiode6$PGoff,0.0);
    if(!tmp12)
    {
      tmp13 = modelica_real_to_modelica_string_format($PIdealDiode6$PGoff, "g");
      tmp14 = cat_modelica_string("Variable IdealDiode6.Goff out of [min, max] interval: IdealDiode6.Goff >= 0.0 has value: ",tmp13);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1041,11,1042,66,0};
      omc_assert_warning(info, tmp14);
      tmp15 = 1;
    }
  }
}
/*
 equation index: 209
 type: ALGORITHM
 
   assert(IdealDiode6.Ron >= 0.0, "Variable IdealDiode6.Ron out of [min, max] interval: IdealDiode6.Ron >= 0.0 has value: " + String(IdealDiode6.Ron, "g"));
 */
static void eqFunction_209(DATA *data)
{
  modelica_boolean tmp16;
  modelica_string tmp17;
  modelica_string tmp18;
  static int tmp19 = 0;
  if(!tmp19)
  {
    tmp16 = GreaterEq($PIdealDiode6$PRon,0.0);
    if(!tmp16)
    {
      tmp17 = modelica_real_to_modelica_string_format($PIdealDiode6$PRon, "g");
      tmp18 = cat_modelica_string("Variable IdealDiode6.Ron out of [min, max] interval: IdealDiode6.Ron >= 0.0 has value: ",tmp17);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1039,11,1040,75,0};
      omc_assert_warning(info, tmp18);
      tmp19 = 1;
    }
  }
}
/*
 equation index: 210
 type: ALGORITHM
 
   assert(IdealDiode6.T >= 0.0, "Variable IdealDiode6.T out of [min, max] interval: IdealDiode6.T >= 0.0 has value: " + String(IdealDiode6.T, "g"));
 */
static void eqFunction_210(DATA *data)
{
  modelica_boolean tmp20;
  modelica_string tmp21;
  modelica_string tmp22;
  static int tmp23 = 0;
  if(!tmp23)
  {
    tmp20 = GreaterEq($PIdealDiode6$PT,0.0);
    if(!tmp20)
    {
      tmp21 = modelica_real_to_modelica_string_format($PIdealDiode6$PT, "g");
      tmp22 = cat_modelica_string("Variable IdealDiode6.T out of [min, max] interval: IdealDiode6.T >= 0.0 has value: ",tmp21);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp22);
      tmp23 = 1;
    }
  }
}
/*
 equation index: 211
 type: ALGORITHM
 
   assert(IdealDiode5.Vknee >= 0.0, "Variable IdealDiode5.Vknee out of [min, max] interval: IdealDiode5.Vknee >= 0.0 has value: " + String(IdealDiode5.Vknee, "g"));
 */
static void eqFunction_211(DATA *data)
{
  modelica_boolean tmp24;
  modelica_string tmp25;
  modelica_string tmp26;
  static int tmp27 = 0;
  if(!tmp27)
  {
    tmp24 = GreaterEq($PIdealDiode5$PVknee,0.0);
    if(!tmp24)
    {
      tmp25 = modelica_real_to_modelica_string_format($PIdealDiode5$PVknee, "g");
      tmp26 = cat_modelica_string("Variable IdealDiode5.Vknee out of [min, max] interval: IdealDiode5.Vknee >= 0.0 has value: ",tmp25);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1043,11,1044,34,0};
      omc_assert_warning(info, tmp26);
      tmp27 = 1;
    }
  }
}
/*
 equation index: 212
 type: ALGORITHM
 
   assert(IdealDiode5.Goff >= 0.0, "Variable IdealDiode5.Goff out of [min, max] interval: IdealDiode5.Goff >= 0.0 has value: " + String(IdealDiode5.Goff, "g"));
 */
static void eqFunction_212(DATA *data)
{
  modelica_boolean tmp28;
  modelica_string tmp29;
  modelica_string tmp30;
  static int tmp31 = 0;
  if(!tmp31)
  {
    tmp28 = GreaterEq($PIdealDiode5$PGoff,0.0);
    if(!tmp28)
    {
      tmp29 = modelica_real_to_modelica_string_format($PIdealDiode5$PGoff, "g");
      tmp30 = cat_modelica_string("Variable IdealDiode5.Goff out of [min, max] interval: IdealDiode5.Goff >= 0.0 has value: ",tmp29);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1041,11,1042,66,0};
      omc_assert_warning(info, tmp30);
      tmp31 = 1;
    }
  }
}
/*
 equation index: 213
 type: ALGORITHM
 
   assert(IdealDiode5.Ron >= 0.0, "Variable IdealDiode5.Ron out of [min, max] interval: IdealDiode5.Ron >= 0.0 has value: " + String(IdealDiode5.Ron, "g"));
 */
static void eqFunction_213(DATA *data)
{
  modelica_boolean tmp32;
  modelica_string tmp33;
  modelica_string tmp34;
  static int tmp35 = 0;
  if(!tmp35)
  {
    tmp32 = GreaterEq($PIdealDiode5$PRon,0.0);
    if(!tmp32)
    {
      tmp33 = modelica_real_to_modelica_string_format($PIdealDiode5$PRon, "g");
      tmp34 = cat_modelica_string("Variable IdealDiode5.Ron out of [min, max] interval: IdealDiode5.Ron >= 0.0 has value: ",tmp33);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1039,11,1040,75,0};
      omc_assert_warning(info, tmp34);
      tmp35 = 1;
    }
  }
}
/*
 equation index: 214
 type: ALGORITHM
 
   assert(IdealDiode5.T >= 0.0, "Variable IdealDiode5.T out of [min, max] interval: IdealDiode5.T >= 0.0 has value: " + String(IdealDiode5.T, "g"));
 */
static void eqFunction_214(DATA *data)
{
  modelica_boolean tmp36;
  modelica_string tmp37;
  modelica_string tmp38;
  static int tmp39 = 0;
  if(!tmp39)
  {
    tmp36 = GreaterEq($PIdealDiode5$PT,0.0);
    if(!tmp36)
    {
      tmp37 = modelica_real_to_modelica_string_format($PIdealDiode5$PT, "g");
      tmp38 = cat_modelica_string("Variable IdealDiode5.T out of [min, max] interval: IdealDiode5.T >= 0.0 has value: ",tmp37);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp38);
      tmp39 = 1;
    }
  }
}
/*
 equation index: 215
 type: ALGORITHM
 
   assert(IdealDiode4.Vknee >= 0.0, "Variable IdealDiode4.Vknee out of [min, max] interval: IdealDiode4.Vknee >= 0.0 has value: " + String(IdealDiode4.Vknee, "g"));
 */
static void eqFunction_215(DATA *data)
{
  modelica_boolean tmp40;
  modelica_string tmp41;
  modelica_string tmp42;
  static int tmp43 = 0;
  if(!tmp43)
  {
    tmp40 = GreaterEq($PIdealDiode4$PVknee,0.0);
    if(!tmp40)
    {
      tmp41 = modelica_real_to_modelica_string_format($PIdealDiode4$PVknee, "g");
      tmp42 = cat_modelica_string("Variable IdealDiode4.Vknee out of [min, max] interval: IdealDiode4.Vknee >= 0.0 has value: ",tmp41);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1043,11,1044,34,0};
      omc_assert_warning(info, tmp42);
      tmp43 = 1;
    }
  }
}
/*
 equation index: 216
 type: ALGORITHM
 
   assert(IdealDiode4.Goff >= 0.0, "Variable IdealDiode4.Goff out of [min, max] interval: IdealDiode4.Goff >= 0.0 has value: " + String(IdealDiode4.Goff, "g"));
 */
static void eqFunction_216(DATA *data)
{
  modelica_boolean tmp44;
  modelica_string tmp45;
  modelica_string tmp46;
  static int tmp47 = 0;
  if(!tmp47)
  {
    tmp44 = GreaterEq($PIdealDiode4$PGoff,0.0);
    if(!tmp44)
    {
      tmp45 = modelica_real_to_modelica_string_format($PIdealDiode4$PGoff, "g");
      tmp46 = cat_modelica_string("Variable IdealDiode4.Goff out of [min, max] interval: IdealDiode4.Goff >= 0.0 has value: ",tmp45);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1041,11,1042,66,0};
      omc_assert_warning(info, tmp46);
      tmp47 = 1;
    }
  }
}
/*
 equation index: 217
 type: ALGORITHM
 
   assert(IdealDiode4.Ron >= 0.0, "Variable IdealDiode4.Ron out of [min, max] interval: IdealDiode4.Ron >= 0.0 has value: " + String(IdealDiode4.Ron, "g"));
 */
static void eqFunction_217(DATA *data)
{
  modelica_boolean tmp48;
  modelica_string tmp49;
  modelica_string tmp50;
  static int tmp51 = 0;
  if(!tmp51)
  {
    tmp48 = GreaterEq($PIdealDiode4$PRon,0.0);
    if(!tmp48)
    {
      tmp49 = modelica_real_to_modelica_string_format($PIdealDiode4$PRon, "g");
      tmp50 = cat_modelica_string("Variable IdealDiode4.Ron out of [min, max] interval: IdealDiode4.Ron >= 0.0 has value: ",tmp49);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1039,11,1040,75,0};
      omc_assert_warning(info, tmp50);
      tmp51 = 1;
    }
  }
}
/*
 equation index: 218
 type: ALGORITHM
 
   assert(IdealDiode4.T >= 0.0, "Variable IdealDiode4.T out of [min, max] interval: IdealDiode4.T >= 0.0 has value: " + String(IdealDiode4.T, "g"));
 */
static void eqFunction_218(DATA *data)
{
  modelica_boolean tmp52;
  modelica_string tmp53;
  modelica_string tmp54;
  static int tmp55 = 0;
  if(!tmp55)
  {
    tmp52 = GreaterEq($PIdealDiode4$PT,0.0);
    if(!tmp52)
    {
      tmp53 = modelica_real_to_modelica_string_format($PIdealDiode4$PT, "g");
      tmp54 = cat_modelica_string("Variable IdealDiode4.T out of [min, max] interval: IdealDiode4.T >= 0.0 has value: ",tmp53);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp54);
      tmp55 = 1;
    }
  }
}
/*
 equation index: 219
 type: ALGORITHM
 
   assert(IdealDiode3.Vknee >= 0.0, "Variable IdealDiode3.Vknee out of [min, max] interval: IdealDiode3.Vknee >= 0.0 has value: " + String(IdealDiode3.Vknee, "g"));
 */
static void eqFunction_219(DATA *data)
{
  modelica_boolean tmp56;
  modelica_string tmp57;
  modelica_string tmp58;
  static int tmp59 = 0;
  if(!tmp59)
  {
    tmp56 = GreaterEq($PIdealDiode3$PVknee,0.0);
    if(!tmp56)
    {
      tmp57 = modelica_real_to_modelica_string_format($PIdealDiode3$PVknee, "g");
      tmp58 = cat_modelica_string("Variable IdealDiode3.Vknee out of [min, max] interval: IdealDiode3.Vknee >= 0.0 has value: ",tmp57);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1043,11,1044,34,0};
      omc_assert_warning(info, tmp58);
      tmp59 = 1;
    }
  }
}
/*
 equation index: 220
 type: ALGORITHM
 
   assert(IdealDiode3.Goff >= 0.0, "Variable IdealDiode3.Goff out of [min, max] interval: IdealDiode3.Goff >= 0.0 has value: " + String(IdealDiode3.Goff, "g"));
 */
static void eqFunction_220(DATA *data)
{
  modelica_boolean tmp60;
  modelica_string tmp61;
  modelica_string tmp62;
  static int tmp63 = 0;
  if(!tmp63)
  {
    tmp60 = GreaterEq($PIdealDiode3$PGoff,0.0);
    if(!tmp60)
    {
      tmp61 = modelica_real_to_modelica_string_format($PIdealDiode3$PGoff, "g");
      tmp62 = cat_modelica_string("Variable IdealDiode3.Goff out of [min, max] interval: IdealDiode3.Goff >= 0.0 has value: ",tmp61);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1041,11,1042,66,0};
      omc_assert_warning(info, tmp62);
      tmp63 = 1;
    }
  }
}
/*
 equation index: 221
 type: ALGORITHM
 
   assert(IdealDiode3.Ron >= 0.0, "Variable IdealDiode3.Ron out of [min, max] interval: IdealDiode3.Ron >= 0.0 has value: " + String(IdealDiode3.Ron, "g"));
 */
static void eqFunction_221(DATA *data)
{
  modelica_boolean tmp64;
  modelica_string tmp65;
  modelica_string tmp66;
  static int tmp67 = 0;
  if(!tmp67)
  {
    tmp64 = GreaterEq($PIdealDiode3$PRon,0.0);
    if(!tmp64)
    {
      tmp65 = modelica_real_to_modelica_string_format($PIdealDiode3$PRon, "g");
      tmp66 = cat_modelica_string("Variable IdealDiode3.Ron out of [min, max] interval: IdealDiode3.Ron >= 0.0 has value: ",tmp65);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1039,11,1040,75,0};
      omc_assert_warning(info, tmp66);
      tmp67 = 1;
    }
  }
}
/*
 equation index: 222
 type: ALGORITHM
 
   assert(IdealDiode3.T >= 0.0, "Variable IdealDiode3.T out of [min, max] interval: IdealDiode3.T >= 0.0 has value: " + String(IdealDiode3.T, "g"));
 */
static void eqFunction_222(DATA *data)
{
  modelica_boolean tmp68;
  modelica_string tmp69;
  modelica_string tmp70;
  static int tmp71 = 0;
  if(!tmp71)
  {
    tmp68 = GreaterEq($PIdealDiode3$PT,0.0);
    if(!tmp68)
    {
      tmp69 = modelica_real_to_modelica_string_format($PIdealDiode3$PT, "g");
      tmp70 = cat_modelica_string("Variable IdealDiode3.T out of [min, max] interval: IdealDiode3.T >= 0.0 has value: ",tmp69);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp70);
      tmp71 = 1;
    }
  }
}
/*
 equation index: 223
 type: ALGORITHM
 
   assert(IdealDiode2.Vknee >= 0.0, "Variable IdealDiode2.Vknee out of [min, max] interval: IdealDiode2.Vknee >= 0.0 has value: " + String(IdealDiode2.Vknee, "g"));
 */
static void eqFunction_223(DATA *data)
{
  modelica_boolean tmp72;
  modelica_string tmp73;
  modelica_string tmp74;
  static int tmp75 = 0;
  if(!tmp75)
  {
    tmp72 = GreaterEq($PIdealDiode2$PVknee,0.0);
    if(!tmp72)
    {
      tmp73 = modelica_real_to_modelica_string_format($PIdealDiode2$PVknee, "g");
      tmp74 = cat_modelica_string("Variable IdealDiode2.Vknee out of [min, max] interval: IdealDiode2.Vknee >= 0.0 has value: ",tmp73);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1043,11,1044,34,0};
      omc_assert_warning(info, tmp74);
      tmp75 = 1;
    }
  }
}
/*
 equation index: 224
 type: ALGORITHM
 
   assert(IdealDiode2.Goff >= 0.0, "Variable IdealDiode2.Goff out of [min, max] interval: IdealDiode2.Goff >= 0.0 has value: " + String(IdealDiode2.Goff, "g"));
 */
static void eqFunction_224(DATA *data)
{
  modelica_boolean tmp76;
  modelica_string tmp77;
  modelica_string tmp78;
  static int tmp79 = 0;
  if(!tmp79)
  {
    tmp76 = GreaterEq($PIdealDiode2$PGoff,0.0);
    if(!tmp76)
    {
      tmp77 = modelica_real_to_modelica_string_format($PIdealDiode2$PGoff, "g");
      tmp78 = cat_modelica_string("Variable IdealDiode2.Goff out of [min, max] interval: IdealDiode2.Goff >= 0.0 has value: ",tmp77);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1041,11,1042,66,0};
      omc_assert_warning(info, tmp78);
      tmp79 = 1;
    }
  }
}
/*
 equation index: 225
 type: ALGORITHM
 
   assert(IdealDiode2.Ron >= 0.0, "Variable IdealDiode2.Ron out of [min, max] interval: IdealDiode2.Ron >= 0.0 has value: " + String(IdealDiode2.Ron, "g"));
 */
static void eqFunction_225(DATA *data)
{
  modelica_boolean tmp80;
  modelica_string tmp81;
  modelica_string tmp82;
  static int tmp83 = 0;
  if(!tmp83)
  {
    tmp80 = GreaterEq($PIdealDiode2$PRon,0.0);
    if(!tmp80)
    {
      tmp81 = modelica_real_to_modelica_string_format($PIdealDiode2$PRon, "g");
      tmp82 = cat_modelica_string("Variable IdealDiode2.Ron out of [min, max] interval: IdealDiode2.Ron >= 0.0 has value: ",tmp81);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1039,11,1040,75,0};
      omc_assert_warning(info, tmp82);
      tmp83 = 1;
    }
  }
}
/*
 equation index: 226
 type: ALGORITHM
 
   assert(IdealDiode2.T >= 0.0, "Variable IdealDiode2.T out of [min, max] interval: IdealDiode2.T >= 0.0 has value: " + String(IdealDiode2.T, "g"));
 */
static void eqFunction_226(DATA *data)
{
  modelica_boolean tmp84;
  modelica_string tmp85;
  modelica_string tmp86;
  static int tmp87 = 0;
  if(!tmp87)
  {
    tmp84 = GreaterEq($PIdealDiode2$PT,0.0);
    if(!tmp84)
    {
      tmp85 = modelica_real_to_modelica_string_format($PIdealDiode2$PT, "g");
      tmp86 = cat_modelica_string("Variable IdealDiode2.T out of [min, max] interval: IdealDiode2.T >= 0.0 has value: ",tmp85);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp86);
      tmp87 = 1;
    }
  }
}
/*
 equation index: 227
 type: ALGORITHM
 
   assert(IdealDiode1.Vknee >= 0.0, "Variable IdealDiode1.Vknee out of [min, max] interval: IdealDiode1.Vknee >= 0.0 has value: " + String(IdealDiode1.Vknee, "g"));
 */
static void eqFunction_227(DATA *data)
{
  modelica_boolean tmp88;
  modelica_string tmp89;
  modelica_string tmp90;
  static int tmp91 = 0;
  if(!tmp91)
  {
    tmp88 = GreaterEq($PIdealDiode1$PVknee,0.0);
    if(!tmp88)
    {
      tmp89 = modelica_real_to_modelica_string_format($PIdealDiode1$PVknee, "g");
      tmp90 = cat_modelica_string("Variable IdealDiode1.Vknee out of [min, max] interval: IdealDiode1.Vknee >= 0.0 has value: ",tmp89);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1043,11,1044,34,0};
      omc_assert_warning(info, tmp90);
      tmp91 = 1;
    }
  }
}
/*
 equation index: 228
 type: ALGORITHM
 
   assert(IdealDiode1.Goff >= 0.0, "Variable IdealDiode1.Goff out of [min, max] interval: IdealDiode1.Goff >= 0.0 has value: " + String(IdealDiode1.Goff, "g"));
 */
static void eqFunction_228(DATA *data)
{
  modelica_boolean tmp92;
  modelica_string tmp93;
  modelica_string tmp94;
  static int tmp95 = 0;
  if(!tmp95)
  {
    tmp92 = GreaterEq($PIdealDiode1$PGoff,0.0);
    if(!tmp92)
    {
      tmp93 = modelica_real_to_modelica_string_format($PIdealDiode1$PGoff, "g");
      tmp94 = cat_modelica_string("Variable IdealDiode1.Goff out of [min, max] interval: IdealDiode1.Goff >= 0.0 has value: ",tmp93);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1041,11,1042,66,0};
      omc_assert_warning(info, tmp94);
      tmp95 = 1;
    }
  }
}
/*
 equation index: 229
 type: ALGORITHM
 
   assert(IdealDiode1.Ron >= 0.0, "Variable IdealDiode1.Ron out of [min, max] interval: IdealDiode1.Ron >= 0.0 has value: " + String(IdealDiode1.Ron, "g"));
 */
static void eqFunction_229(DATA *data)
{
  modelica_boolean tmp96;
  modelica_string tmp97;
  modelica_string tmp98;
  static int tmp99 = 0;
  if(!tmp99)
  {
    tmp96 = GreaterEq($PIdealDiode1$PRon,0.0);
    if(!tmp96)
    {
      tmp97 = modelica_real_to_modelica_string_format($PIdealDiode1$PRon, "g");
      tmp98 = cat_modelica_string("Variable IdealDiode1.Ron out of [min, max] interval: IdealDiode1.Ron >= 0.0 has value: ",tmp97);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Ideal.mo",1039,11,1040,75,0};
      omc_assert_warning(info, tmp98);
      tmp99 = 1;
    }
  }
}
/*
 equation index: 230
 type: ALGORITHM
 
   assert(IdealDiode1.T >= 0.0, "Variable IdealDiode1.T out of [min, max] interval: IdealDiode1.T >= 0.0 has value: " + String(IdealDiode1.T, "g"));
 */
static void eqFunction_230(DATA *data)
{
  modelica_boolean tmp100;
  modelica_string tmp101;
  modelica_string tmp102;
  static int tmp103 = 0;
  if(!tmp103)
  {
    tmp100 = GreaterEq($PIdealDiode1$PT,0.0);
    if(!tmp100)
    {
      tmp101 = modelica_real_to_modelica_string_format($PIdealDiode1$PT, "g");
      tmp102 = cat_modelica_string("Variable IdealDiode1.T out of [min, max] interval: IdealDiode1.T >= 0.0 has value: ",tmp101);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Interfaces.mo",306,5,307,99,0};
      omc_assert_warning(info, tmp102);
      tmp103 = 1;
    }
  }
}
/*
 equation index: 231
 type: ALGORITHM
 
   assert(CDC >= 0.0, "Variable CDC out of [min, max] interval: CDC >= 0.0 has value: " + String(CDC, "g"));
 */
static void eqFunction_231(DATA *data)
{
  modelica_boolean tmp104;
  modelica_string tmp105;
  modelica_string tmp106;
  static int tmp107 = 0;
  if(!tmp107)
  {
    tmp104 = GreaterEq($PCDC,0.0);
    if(!tmp104)
    {
      tmp105 = modelica_real_to_modelica_string_format($PCDC, "g");
      tmp106 = cat_modelica_string("Variable CDC out of [min, max] interval: CDC >= 0.0 has value: ",tmp105);
      FILE_INFO info = {"/home/tshort/openmodelica/build/lib/omlibrary/Modelica 3.2.1/Electrical/Analog/Examples/Rectifier.mo",11,3,11,68,0};
      omc_assert_warning(info, tmp106);
      tmp107 = 1;
    }
  }
}
int updateBoundParameters(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  eqFunction_159(data);
  restore_memory_state(mem_state);
  eqFunction_160(data);
  restore_memory_state(mem_state);
  eqFunction_161(data);
  restore_memory_state(mem_state);
  eqFunction_162(data);
  restore_memory_state(mem_state);
  eqFunction_163(data);
  restore_memory_state(mem_state);
  eqFunction_164(data);
  restore_memory_state(mem_state);
  eqFunction_165(data);
  restore_memory_state(mem_state);
  eqFunction_166(data);
  restore_memory_state(mem_state);
  eqFunction_167(data);
  restore_memory_state(mem_state);
  eqFunction_168(data);
  restore_memory_state(mem_state);
  eqFunction_169(data);
  restore_memory_state(mem_state);
  eqFunction_170(data);
  restore_memory_state(mem_state);
  eqFunction_171(data);
  restore_memory_state(mem_state);
  eqFunction_172(data);
  restore_memory_state(mem_state);
  eqFunction_173(data);
  restore_memory_state(mem_state);
  eqFunction_174(data);
  restore_memory_state(mem_state);
  eqFunction_175(data);
  restore_memory_state(mem_state);
  eqFunction_176(data);
  restore_memory_state(mem_state);
  eqFunction_177(data);
  restore_memory_state(mem_state);
  eqFunction_178(data);
  restore_memory_state(mem_state);
  eqFunction_179(data);
  restore_memory_state(mem_state);
  eqFunction_180(data);
  restore_memory_state(mem_state);
  eqFunction_181(data);
  restore_memory_state(mem_state);
  eqFunction_182(data);
  restore_memory_state(mem_state);
  eqFunction_183(data);
  restore_memory_state(mem_state);
  eqFunction_184(data);
  restore_memory_state(mem_state);
  eqFunction_185(data);
  restore_memory_state(mem_state);
  eqFunction_186(data);
  restore_memory_state(mem_state);
  eqFunction_187(data);
  restore_memory_state(mem_state);
  eqFunction_188(data);
  restore_memory_state(mem_state);
  eqFunction_189(data);
  restore_memory_state(mem_state);
  eqFunction_190(data);
  restore_memory_state(mem_state);
  eqFunction_191(data);
  restore_memory_state(mem_state);
  eqFunction_192(data);
  restore_memory_state(mem_state);
  eqFunction_193(data);
  restore_memory_state(mem_state);
  eqFunction_194(data);
  restore_memory_state(mem_state);
  eqFunction_195(data);
  restore_memory_state(mem_state);
  eqFunction_196(data);
  restore_memory_state(mem_state);
  eqFunction_197(data);
  restore_memory_state(mem_state);
  eqFunction_198(data);
  restore_memory_state(mem_state);
  eqFunction_199(data);
  restore_memory_state(mem_state);
  eqFunction_200(data);
  restore_memory_state(mem_state);
  eqFunction_201(data);
  restore_memory_state(mem_state);
  eqFunction_202(data);
  restore_memory_state(mem_state);
  eqFunction_203(data);
  restore_memory_state(mem_state);
  eqFunction_204(data);
  restore_memory_state(mem_state);
  eqFunction_205(data);
  restore_memory_state(mem_state);
  eqFunction_206(data);
  restore_memory_state(mem_state);
  eqFunction_207(data);
  restore_memory_state(mem_state);
  eqFunction_208(data);
  restore_memory_state(mem_state);
  eqFunction_209(data);
  restore_memory_state(mem_state);
  eqFunction_210(data);
  restore_memory_state(mem_state);
  eqFunction_211(data);
  restore_memory_state(mem_state);
  eqFunction_212(data);
  restore_memory_state(mem_state);
  eqFunction_213(data);
  restore_memory_state(mem_state);
  eqFunction_214(data);
  restore_memory_state(mem_state);
  eqFunction_215(data);
  restore_memory_state(mem_state);
  eqFunction_216(data);
  restore_memory_state(mem_state);
  eqFunction_217(data);
  restore_memory_state(mem_state);
  eqFunction_218(data);
  restore_memory_state(mem_state);
  eqFunction_219(data);
  restore_memory_state(mem_state);
  eqFunction_220(data);
  restore_memory_state(mem_state);
  eqFunction_221(data);
  restore_memory_state(mem_state);
  eqFunction_222(data);
  restore_memory_state(mem_state);
  eqFunction_223(data);
  restore_memory_state(mem_state);
  eqFunction_224(data);
  restore_memory_state(mem_state);
  eqFunction_225(data);
  restore_memory_state(mem_state);
  eqFunction_226(data);
  restore_memory_state(mem_state);
  eqFunction_227(data);
  restore_memory_state(mem_state);
  eqFunction_228(data);
  restore_memory_state(mem_state);
  eqFunction_229(data);
  restore_memory_state(mem_state);
  eqFunction_230(data);
  restore_memory_state(mem_state);
  eqFunction_231(data);
  restore_memory_state(mem_state);
  
  return 0;
}


/*
 equation index: 105
 type: SIMPLE_ASSIGN
 SignalCurrent1._v = Capacitor1.v + Capacitor2.v
 */
static void eqFunction_105(DATA *data)
{
  $PSignalCurrent1$Pv = ($PCapacitor1$Pv + $PCapacitor2$Pv);
}
/*
 equation index: 106
 type: SIMPLE_ASSIGN
 SineVoltage1._v = SineVoltage1.signalSource.offset + (if time < SineVoltage1.signalSource.startTime then 0.0 else SineVoltage1.signalSource.amplitude * sin(6.283185307179586 * SineVoltage1.signalSource.freqHz * (time - SineVoltage1.signalSource.startTime) + SineVoltage1.signalSource.phase))
 */
static void eqFunction_106(DATA *data)
{
  modelica_boolean tmp108;
  modelica_real tmp109;
  modelica_boolean tmp110;
  modelica_real tmp111;
  RELATIONHYSTERESIS(tmp108, time, $PSineVoltage1$PsignalSource$PstartTime, 8, Less);
  tmp110 = (modelica_boolean)tmp108;
  if(tmp110)
  {
    tmp111 = 0.0;
  }
  else
  {
    tmp109 = sin(((6.283185307179586 * ($PSineVoltage1$PsignalSource$PfreqHz * (time - $PSineVoltage1$PsignalSource$PstartTime))) + $PSineVoltage1$PsignalSource$Pphase));
    tmp111 = ($PSineVoltage1$PsignalSource$Pamplitude * tmp109);
  }
  $PSineVoltage1$Pv = ($PSineVoltage1$PsignalSource$Poffset + tmp111);
}
/*
 equation index: 107
 type: SIMPLE_ASSIGN
 SineVoltage2._v = SineVoltage2.signalSource.offset + (if time < SineVoltage2.signalSource.startTime then 0.0 else SineVoltage2.signalSource.amplitude * sin(6.283185307179586 * SineVoltage2.signalSource.freqHz * (time - SineVoltage2.signalSource.startTime) + SineVoltage2.signalSource.phase))
 */
static void eqFunction_107(DATA *data)
{
  modelica_boolean tmp112;
  modelica_real tmp113;
  modelica_boolean tmp114;
  modelica_real tmp115;
  RELATIONHYSTERESIS(tmp112, time, $PSineVoltage2$PsignalSource$PstartTime, 7, Less);
  tmp114 = (modelica_boolean)tmp112;
  if(tmp114)
  {
    tmp115 = 0.0;
  }
  else
  {
    tmp113 = sin(((6.283185307179586 * ($PSineVoltage2$PsignalSource$PfreqHz * (time - $PSineVoltage2$PsignalSource$PstartTime))) + $PSineVoltage2$PsignalSource$Pphase));
    tmp115 = ($PSineVoltage2$PsignalSource$Pamplitude * tmp113);
  }
  $PSineVoltage2$Pv = ($PSineVoltage2$PsignalSource$Poffset + tmp115);
}
/*
 equation index: 108
 type: SIMPLE_ASSIGN
 SineVoltage3._v = SineVoltage3.signalSource.offset + (if time < SineVoltage3.signalSource.startTime then 0.0 else SineVoltage3.signalSource.amplitude * sin(6.283185307179586 * SineVoltage3.signalSource.freqHz * (time - SineVoltage3.signalSource.startTime) + SineVoltage3.signalSource.phase))
 */
static void eqFunction_108(DATA *data)
{
  modelica_boolean tmp116;
  modelica_real tmp117;
  modelica_boolean tmp118;
  modelica_real tmp119;
  RELATIONHYSTERESIS(tmp116, time, $PSineVoltage3$PsignalSource$PstartTime, 6, Less);
  tmp118 = (modelica_boolean)tmp116;
  if(tmp118)
  {
    tmp119 = 0.0;
  }
  else
  {
    tmp117 = sin(((6.283185307179586 * ($PSineVoltage3$PsignalSource$PfreqHz * (time - $PSineVoltage3$PsignalSource$PstartTime))) + $PSineVoltage3$PsignalSource$Pphase));
    tmp119 = ($PSineVoltage3$PsignalSource$Pamplitude * tmp117);
  }
  $PSineVoltage3$Pv = ($PSineVoltage3$PsignalSource$Poffset + tmp119);
}
/*
 equation index: 118
 indexNonlinear: 3
 type: NONLINEAR
 
 vars: {IdealDiode5._s, IdealDiode2._s}
 eqns: {109, 110, 111, 112, 113, 114, 115, 117, 116}
 */
static void eqFunction_118(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,118).profileBlockIndex);
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,118).profileBlockIndex,-1);
  #endif
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[3].nlsx[0] = $PIdealDiode5$Ps;
  data->simulationInfo.nonlinearSystemData[3].nlsxOld[0] = _$PIdealDiode5$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[3].nlsxExtrapolation[0] = extraPolate(data, _$PIdealDiode5$Ps(1) /*old*/, _$PIdealDiode5$Ps(2) /*old2*/);
  data->simulationInfo.nonlinearSystemData[3].nlsx[1] = $PIdealDiode2$Ps;
  data->simulationInfo.nonlinearSystemData[3].nlsxOld[1] = _$PIdealDiode2$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[3].nlsxExtrapolation[1] = extraPolate(data, _$PIdealDiode2$Ps(1) /*old*/, _$PIdealDiode2$Ps(2) /*old2*/);
  solve_nonlinear_system(data, 3);
  /* write solution */
  $PIdealDiode5$Ps = data->simulationInfo.nonlinearSystemData[3].nlsx[0];
  $PIdealDiode2$Ps = data->simulationInfo.nonlinearSystemData[3].nlsx[1];
  /* update inner equations */
  eqFunction_109(data);
  eqFunction_110(data);
  eqFunction_111(data);
  eqFunction_112(data);
  eqFunction_113(data);
  eqFunction_114(data);
  eqFunction_115(data);
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,118).profileBlockIndex);
  #endif
}
/*
 equation index: 119
 type: SIMPLE_ASSIGN
 IdealDiode2._LossPower = IdealDiode2.v * IdealDiode2.i
 */
static void eqFunction_119(DATA *data)
{
  $PIdealDiode2$PLossPower = ($PIdealDiode2$Pv * $PIdealDiode2$Pi);
}
/*
 equation index: 120
 type: SIMPLE_ASSIGN
 IdealDiode5._LossPower = IdealDiode5.v * IdealDiode5.i
 */
static void eqFunction_120(DATA *data)
{
  $PIdealDiode5$PLossPower = ($PIdealDiode5$Pv * $PIdealDiode5$Pi);
}
/*
 equation index: 130
 indexNonlinear: 4
 type: NONLINEAR
 
 vars: {IdealDiode6._s, IdealDiode3._s}
 eqns: {121, 122, 123, 124, 125, 126, 127, 129, 128}
 */
static void eqFunction_130(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,130).profileBlockIndex);
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,130).profileBlockIndex,-1);
  #endif
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[4].nlsx[0] = $PIdealDiode6$Ps;
  data->simulationInfo.nonlinearSystemData[4].nlsxOld[0] = _$PIdealDiode6$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[4].nlsxExtrapolation[0] = extraPolate(data, _$PIdealDiode6$Ps(1) /*old*/, _$PIdealDiode6$Ps(2) /*old2*/);
  data->simulationInfo.nonlinearSystemData[4].nlsx[1] = $PIdealDiode3$Ps;
  data->simulationInfo.nonlinearSystemData[4].nlsxOld[1] = _$PIdealDiode3$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[4].nlsxExtrapolation[1] = extraPolate(data, _$PIdealDiode3$Ps(1) /*old*/, _$PIdealDiode3$Ps(2) /*old2*/);
  solve_nonlinear_system(data, 4);
  /* write solution */
  $PIdealDiode6$Ps = data->simulationInfo.nonlinearSystemData[4].nlsx[0];
  $PIdealDiode3$Ps = data->simulationInfo.nonlinearSystemData[4].nlsx[1];
  /* update inner equations */
  eqFunction_121(data);
  eqFunction_122(data);
  eqFunction_123(data);
  eqFunction_124(data);
  eqFunction_125(data);
  eqFunction_126(data);
  eqFunction_127(data);
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,130).profileBlockIndex);
  #endif
}
/*
 equation index: 131
 type: SIMPLE_ASSIGN
 uAC[2] = IdealDiode2.p.v - IdealDiode3.p.v
 */
static void eqFunction_131(DATA *data)
{
  $PuAC$lB2$rB = ($PIdealDiode2$Pp$Pv - $PIdealDiode3$Pp$Pv);
}
/*
 equation index: 132
 type: SIMPLE_ASSIGN
 IdealDiode3._LossPower = IdealDiode3.v * IdealDiode3.i
 */
static void eqFunction_132(DATA *data)
{
  $PIdealDiode3$PLossPower = ($PIdealDiode3$Pv * $PIdealDiode3$Pi);
}
/*
 equation index: 133
 type: SIMPLE_ASSIGN
 IdealDiode6._LossPower = IdealDiode6.v * IdealDiode6.i
 */
static void eqFunction_133(DATA *data)
{
  $PIdealDiode6$PLossPower = ($PIdealDiode6$Pv * $PIdealDiode6$Pi);
}
/*
 equation index: 134
 type: SIMPLE_ASSIGN
 uDC = Capacitor1.v + Capacitor2.v
 */
static void eqFunction_134(DATA *data)
{
  $PuDC = ($PCapacitor1$Pv + $PCapacitor2$Pv);
}
/*
 equation index: 135
 type: SIMPLE_ASSIGN
 iAC[3] = Inductor3.i
 */
static void eqFunction_135(DATA *data)
{
  $PiAC$lB3$rB = $PInductor3$Pi;
}
/*
 equation index: 136
 type: SIMPLE_ASSIGN
 iAC[2] = Inductor2.i
 */
static void eqFunction_136(DATA *data)
{
  $PiAC$lB2$rB = $PInductor2$Pi;
}
/*
 equation index: 137
 type: SIMPLE_ASSIGN
 iAC[1] = (-Inductor2.i) - Inductor3.i
 */
static void eqFunction_137(DATA *data)
{
  $PiAC$lB1$rB = ((-$PInductor2$Pi) - $PInductor3$Pi);
}
/*
 equation index: 147
 indexNonlinear: 5
 type: NONLINEAR
 
 vars: {IdealDiode4._s, IdealDiode1._s}
 eqns: {138, 139, 140, 141, 142, 143, 144, 146, 145}
 */
static void eqFunction_147(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,147).profileBlockIndex);
  SIM_PROF_ADD_NCALL_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,147).profileBlockIndex,-1);
  #endif
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[5].nlsx[0] = $PIdealDiode4$Ps;
  data->simulationInfo.nonlinearSystemData[5].nlsxOld[0] = _$PIdealDiode4$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[5].nlsxExtrapolation[0] = extraPolate(data, _$PIdealDiode4$Ps(1) /*old*/, _$PIdealDiode4$Ps(2) /*old2*/);
  data->simulationInfo.nonlinearSystemData[5].nlsx[1] = $PIdealDiode1$Ps;
  data->simulationInfo.nonlinearSystemData[5].nlsxOld[1] = _$PIdealDiode1$Ps(1) /*old*/;
  data->simulationInfo.nonlinearSystemData[5].nlsxExtrapolation[1] = extraPolate(data, _$PIdealDiode1$Ps(1) /*old*/, _$PIdealDiode1$Ps(2) /*old2*/);
  solve_nonlinear_system(data, 5);
  /* write solution */
  $PIdealDiode4$Ps = data->simulationInfo.nonlinearSystemData[5].nlsx[0];
  $PIdealDiode1$Ps = data->simulationInfo.nonlinearSystemData[5].nlsx[1];
  /* update inner equations */
  eqFunction_138(data);
  eqFunction_139(data);
  eqFunction_140(data);
  eqFunction_141(data);
  eqFunction_142(data);
  eqFunction_143(data);
  eqFunction_144(data);
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,147).profileBlockIndex);
  #endif
}
/*
 equation index: 148
 type: SIMPLE_ASSIGN
 Capacitor2._i = IdealDiode4.i + IdealDiode5.i + IdealDiode6.i - Constant1.k
 */
static void eqFunction_148(DATA *data)
{
  $PCapacitor2$Pi = ($PIdealDiode4$Pi + ($PIdealDiode5$Pi + ($PIdealDiode6$Pi - $PConstant1$Pk)));
}
/*
 equation index: 149
 type: SIMPLE_ASSIGN
 der(Capacitor2._v) = DIVISION(Capacitor2.i, Capacitor2.C, #SHARED_LITERAL_2(String)#)
 */
static void eqFunction_149(DATA *data)
{
  modelica_real tmp126;
  tmp126 = DIVISION($PCapacitor2$Pi, $PCapacitor2$PC, _OMC_LIT2);
  $P$DER$PCapacitor2$Pv = tmp126;
}
/*
 equation index: 150
 type: SIMPLE_ASSIGN
 IdealDiode4._LossPower = IdealDiode4.v * IdealDiode4.i
 */
static void eqFunction_150(DATA *data)
{
  $PIdealDiode4$PLossPower = ($PIdealDiode4$Pv * $PIdealDiode4$Pi);
}
/*
 equation index: 151
 type: SIMPLE_ASSIGN
 uAC[1] = IdealDiode1.p.v - IdealDiode2.p.v
 */
static void eqFunction_151(DATA *data)
{
  $PuAC$lB1$rB = ($PIdealDiode1$Pp$Pv - $PIdealDiode2$Pp$Pv);
}
/*
 equation index: 152
 type: SIMPLE_ASSIGN
 uAC[3] = IdealDiode3.p.v - IdealDiode1.p.v
 */
static void eqFunction_152(DATA *data)
{
  $PuAC$lB3$rB = ($PIdealDiode3$Pp$Pv - $PIdealDiode1$Pp$Pv);
}
/*
 equation index: 153
 type: LINEAR
 
 <var>Inductor1._p._v</var>
 <var>der(Inductor2._i)</var>
 <var>Inductor2._v</var>
 <var>Inductor2._p._v</var>
 <var>SineVoltage1._n._v</var>
 <var>Inductor3._p._v</var>
 <var>Inductor3._v</var>
 <var>der(Inductor3._i)</var>
 <var>der(Inductor1._i)</var>
 <var>Inductor1._v</var>
 <row>
   <cell>-IdealDiode1.p.v</cell>
   <cell>0.0</cell>
   <cell>0.0</cell>
   <cell>0.0</cell>
   <cell>-IdealDiode3.p.v</cell>
   <cell>-SineVoltage3.v</cell>
   <cell>-SineVoltage2.v</cell>
   <cell>-IdealDiode2.p.v</cell>
   <cell>0.0</cell>
   <cell>-SineVoltage1.v</cell>
 </row>
 <matrix>
   <cell row="0" col="0">
     <residual>-1.0</residual>
   </cell><cell row="0" col="9">
     <residual>1.0</residual>
   </cell><cell row="1" col="8">
     <residual>Inductor1.L</residual>
   </cell><cell row="1" col="9">
     <residual>-1.0</residual>
   </cell><cell row="2" col="1">
     <residual>1.0</residual>
   </cell><cell row="2" col="7">
     <residual>1.0</residual>
   </cell><cell row="2" col="8">
     <residual>1.0</residual>
   </cell><cell row="3" col="6">
     <residual>-1.0</residual>
   </cell><cell row="3" col="7">
     <residual>Inductor3.L</residual>
   </cell><cell row="4" col="5">
     <residual>-1.0</residual>
   </cell><cell row="4" col="6">
     <residual>1.0</residual>
   </cell><cell row="5" col="4">
     <residual>1.0</residual>
   </cell><cell row="5" col="5">
     <residual>-1.0</residual>
   </cell><cell row="6" col="3">
     <residual>-1.0</residual>
   </cell><cell row="6" col="4">
     <residual>1.0</residual>
   </cell><cell row="7" col="2">
     <residual>1.0</residual>
   </cell><cell row="7" col="3">
     <residual>-1.0</residual>
   </cell><cell row="8" col="1">
     <residual>Inductor2.L</residual>
   </cell><cell row="8" col="2">
     <residual>-1.0</residual>
   </cell><cell row="9" col="0">
     <residual>-1.0</residual>
   </cell><cell row="9" col="4">
     <residual>1.0</residual>
   </cell>
 </matrix>
 */
static void eqFunction_153(DATA *data)
{
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_TICK_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,153).profileBlockIndex);
  #endif
  /* Linear equation system */
  solve_linear_system(data, 1);
  $PInductor1$Pp$Pv = data->simulationInfo.linearSystemData[1].x[0];
  $P$DER$PInductor2$Pi = data->simulationInfo.linearSystemData[1].x[1];
  $PInductor2$Pv = data->simulationInfo.linearSystemData[1].x[2];
  $PInductor2$Pp$Pv = data->simulationInfo.linearSystemData[1].x[3];
  $PSineVoltage1$Pn$Pv = data->simulationInfo.linearSystemData[1].x[4];
  $PInductor3$Pp$Pv = data->simulationInfo.linearSystemData[1].x[5];
  $PInductor3$Pv = data->simulationInfo.linearSystemData[1].x[6];
  $P$DER$PInductor3$Pi = data->simulationInfo.linearSystemData[1].x[7];
  $P$DER$PInductor1$Pi = data->simulationInfo.linearSystemData[1].x[8];
  $PInductor1$Pv = data->simulationInfo.linearSystemData[1].x[9];
  #ifdef _OMC_MEASURE_TIME
  SIM_PROF_ACC_EQ(modelInfoXmlGetEquation(&data->modelData.modelDataXml,153).profileBlockIndex);
  #endif
}
/*
 equation index: 154
 type: SIMPLE_ASSIGN
 IdealDiode1._LossPower = IdealDiode1.v * IdealDiode1.i
 */
static void eqFunction_154(DATA *data)
{
  $PIdealDiode1$PLossPower = ($PIdealDiode1$Pv * $PIdealDiode1$Pi);
}
/*
 equation index: 155
 type: SIMPLE_ASSIGN
 Losses = IdealDiode1.LossPower + IdealDiode2.LossPower + IdealDiode3.LossPower + IdealDiode4.LossPower + IdealDiode5.LossPower + IdealDiode6.LossPower
 */
static void eqFunction_155(DATA *data)
{
  $PLosses = ($PIdealDiode1$PLossPower + ($PIdealDiode2$PLossPower + ($PIdealDiode3$PLossPower + ($PIdealDiode4$PLossPower + ($PIdealDiode5$PLossPower + $PIdealDiode6$PLossPower)))));
}
/*
 equation index: 156
 type: SIMPLE_ASSIGN
 Capacitor1._i = IdealDiode1.i - (-IdealDiode3.i) - IdealDiode2.i - Constant1.k
 */
static void eqFunction_156(DATA *data)
{
  $PCapacitor1$Pi = (($PIdealDiode1$Pi - ((-$PIdealDiode3$Pi) - $PIdealDiode2$Pi)) - $PConstant1$Pk);
}
/*
 equation index: 157
 type: SIMPLE_ASSIGN
 der(Capacitor1._v) = DIVISION(Capacitor1.i, Capacitor1.C, #SHARED_LITERAL_3(String)#)
 */
static void eqFunction_157(DATA *data)
{
  modelica_real tmp127;
  tmp127 = DIVISION($PCapacitor1$Pi, $PCapacitor1$PC, _OMC_LIT3);
  $P$DER$PCapacitor1$Pv = tmp127;
}
/*
 equation index: 158
 type: SIMPLE_ASSIGN
 Ground1._p._i = Capacitor1.i - Capacitor2.i
 */
static void eqFunction_158(DATA *data)
{
  $PGround1$Pp$Pi = ($PCapacitor1$Pi - $PCapacitor2$Pi);
}
int functionDAE(DATA *data)
{
  state mem_state;
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  mem_state = get_memory_state();
  eqFunction_105(data);
  eqFunction_106(data);
  eqFunction_107(data);
  eqFunction_108(data);
  eqFunction_118(data);
  eqFunction_119(data);
  eqFunction_120(data);
  eqFunction_130(data);
  eqFunction_131(data);
  eqFunction_132(data);
  eqFunction_133(data);
  eqFunction_134(data);
  eqFunction_135(data);
  eqFunction_136(data);
  eqFunction_137(data);
  eqFunction_147(data);
  eqFunction_148(data);
  eqFunction_149(data);
  eqFunction_150(data);
  eqFunction_151(data);
  eqFunction_152(data);
  eqFunction_153(data);
  eqFunction_154(data);
  eqFunction_155(data);
  eqFunction_156(data);
  eqFunction_157(data);
  eqFunction_158(data);
  restore_memory_state(mem_state);
  
  return 0;
}

static void functionODE_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(106);
  #endif
  eqFunction_106(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(106);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(107);
  #endif
  eqFunction_107(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(107);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(108);
  #endif
  eqFunction_108(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(108);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(118);
  #endif
  eqFunction_118(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(118);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(130);
  #endif
  eqFunction_130(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(130);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(137);
  #endif
  eqFunction_137(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(137);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(147);
  #endif
  eqFunction_147(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(147);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(148);
  #endif
  eqFunction_148(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(148);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(149);
  #endif
  eqFunction_149(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(149);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(153);
  #endif
  eqFunction_153(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(153);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(156);
  #endif
  eqFunction_156(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(156);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(157);
  #endif
  eqFunction_157(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(157);
  #endif
  restore_memory_state(mem_state);
}

void function_initMemoryState()
{
#ifdef _OPENMP
  push_memory_states(omp_get_max_threads());
  get_thread_index = omp_get_thread_num;
#else
  push_memory_states(1);
#endif
}

int functionODE(DATA *data)
{
#ifdef _OMC_MEASURE_TIME
  rt_tick(SIM_TIMER_FUNCTION_ODE);
#endif

  state mem_state; /* We need to have separate memory pools for separate systems... */
  mem_state = get_memory_state();
  
  data->simulationInfo.discreteCall = 0;
  functionODE_system0(data);
  restore_memory_state(mem_state);
#ifdef _OMC_MEASURE_TIME
  rt_accumulate(SIM_TIMER_FUNCTION_ODE);
#endif

  return 0;
}

#include <simulation_inline_solver.h>
const char *_omc_force_solver=_OMC_FORCE_SOLVER;
const int inline_work_states_ndims=_OMC_SOLVER_WORK_STATES_NDIMS;
int functionODE_inline(DATA* data, double stepSize)
{
  return 0;
}

static void functionAlg_system0(DATA *data)
{
  state mem_state;
  mem_state = get_memory_state();
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(105);
  #endif
  eqFunction_105(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(105);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(119);
  #endif
  eqFunction_119(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(119);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(120);
  #endif
  eqFunction_120(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(120);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(131);
  #endif
  eqFunction_131(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(131);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(132);
  #endif
  eqFunction_132(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(132);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(133);
  #endif
  eqFunction_133(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(133);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(134);
  #endif
  eqFunction_134(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(134);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(135);
  #endif
  eqFunction_135(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(135);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(136);
  #endif
  eqFunction_136(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(136);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(150);
  #endif
  eqFunction_150(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(150);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(151);
  #endif
  eqFunction_151(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(151);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(152);
  #endif
  eqFunction_152(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(152);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(154);
  #endif
  eqFunction_154(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(154);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(155);
  #endif
  eqFunction_155(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(155);
  #endif
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_TICK_EQEXT(158);
  #endif
  eqFunction_158(data);
  #ifdef _OMC_MEASURE_TIME
    SIM_PROF_ACC_EQEXT(158);
  #endif
  restore_memory_state(mem_state);
}
/* for continuous time variables */
int functionAlgebraics(DATA *data)
{
  data->simulationInfo.discreteCall = 0;
  functionAlg_system0(data);
  return 0;
}

const char *zeroCrossingDescription[] =
{
  "IdealDiode6.s < 0.0", 
  "IdealDiode3.s < 0.0", 
  "IdealDiode5.s < 0.0", 
  "IdealDiode2.s < 0.0", 
  "IdealDiode4.s < 0.0", 
  "IdealDiode1.s < 0.0", 
  "time < SineVoltage3.signalSource.startTime", 
  "time < SineVoltage2.signalSource.startTime", 
  "time < SineVoltage1.signalSource.startTime", 
};

int function_ZeroCrossings(DATA *data, double *gout, double *t)
{
  state mem_state;
  modelica_boolean tmp17;
  modelica_boolean tmp18;
  modelica_boolean tmp19;
  modelica_boolean tmp20;
  modelica_boolean tmp21;
  modelica_boolean tmp22;
  modelica_boolean tmp23;
  modelica_boolean tmp24;
  modelica_boolean tmp25;
  
  mem_state = get_memory_state();
  tmp17 = LessZC($PIdealDiode6$Ps,0.0, data->simulationInfo.hysteresisEnabled[0]);
  ZEROCROSSING(0, (tmp17)?1:-1);
  tmp18 = LessZC($PIdealDiode3$Ps,0.0, data->simulationInfo.hysteresisEnabled[1]);
  ZEROCROSSING(1, (tmp18)?1:-1);
  tmp19 = LessZC($PIdealDiode5$Ps,0.0, data->simulationInfo.hysteresisEnabled[2]);
  ZEROCROSSING(2, (tmp19)?1:-1);
  tmp20 = LessZC($PIdealDiode2$Ps,0.0, data->simulationInfo.hysteresisEnabled[3]);
  ZEROCROSSING(3, (tmp20)?1:-1);
  tmp21 = LessZC($PIdealDiode4$Ps,0.0, data->simulationInfo.hysteresisEnabled[4]);
  ZEROCROSSING(4, (tmp21)?1:-1);
  tmp22 = LessZC($PIdealDiode1$Ps,0.0, data->simulationInfo.hysteresisEnabled[5]);
  ZEROCROSSING(5, (tmp22)?1:-1);
  tmp23 = LessZC(time,$PSineVoltage3$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[6]);
  ZEROCROSSING(6, (tmp23)?1:-1);
  tmp24 = LessZC(time,$PSineVoltage2$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[7]);
  ZEROCROSSING(7, (tmp24)?1:-1);
  tmp25 = LessZC(time,$PSineVoltage1$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[8]);
  ZEROCROSSING(8, (tmp25)?1:-1);
  restore_memory_state(mem_state);
  
  return 0;
}

const char *relationDescription[] =
{
  "IdealDiode6.s < 0.0", 
  "IdealDiode3.s < 0.0", 
  "IdealDiode5.s < 0.0", 
  "IdealDiode2.s < 0.0", 
  "IdealDiode4.s < 0.0", 
  "IdealDiode1.s < 0.0", 
  "time < SineVoltage3.signalSource.startTime", 
  "time < SineVoltage2.signalSource.startTime", 
  "time < SineVoltage1.signalSource.startTime", 
};

int function_updateRelations(DATA *data, int evalforZeroCross)
{
  state mem_state;
  modelica_boolean tmp26;
  modelica_boolean tmp27;
  modelica_boolean tmp28;
  modelica_boolean tmp29;
  modelica_boolean tmp30;
  modelica_boolean tmp31;
  modelica_boolean tmp32;
  modelica_boolean tmp33;
  modelica_boolean tmp34;
  
  mem_state = get_memory_state();
  if(evalforZeroCross)
  {
    tmp26 = LessZC($PIdealDiode6$Ps,0.0, data->simulationInfo.hysteresisEnabled[0]);
    data->simulationInfo.relations[0] = tmp26;
    tmp27 = LessZC($PIdealDiode3$Ps,0.0, data->simulationInfo.hysteresisEnabled[1]);
    data->simulationInfo.relations[1] = tmp27;
    tmp28 = LessZC($PIdealDiode5$Ps,0.0, data->simulationInfo.hysteresisEnabled[2]);
    data->simulationInfo.relations[2] = tmp28;
    tmp29 = LessZC($PIdealDiode2$Ps,0.0, data->simulationInfo.hysteresisEnabled[3]);
    data->simulationInfo.relations[3] = tmp29;
    tmp30 = LessZC($PIdealDiode4$Ps,0.0, data->simulationInfo.hysteresisEnabled[4]);
    data->simulationInfo.relations[4] = tmp30;
    tmp31 = LessZC($PIdealDiode1$Ps,0.0, data->simulationInfo.hysteresisEnabled[5]);
    data->simulationInfo.relations[5] = tmp31;
    tmp32 = LessZC(time,$PSineVoltage3$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[6]);
    data->simulationInfo.relations[6] = tmp32;
    tmp33 = LessZC(time,$PSineVoltage2$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[7]);
    data->simulationInfo.relations[7] = tmp33;
    tmp34 = LessZC(time,$PSineVoltage1$PsignalSource$PstartTime, data->simulationInfo.hysteresisEnabled[8]);
    data->simulationInfo.relations[8] = tmp34;
  }
  else
  {
    data->simulationInfo.relations[0] = ($PIdealDiode6$Ps < 0.0);
    data->simulationInfo.relations[1] = ($PIdealDiode3$Ps < 0.0);
    data->simulationInfo.relations[2] = ($PIdealDiode5$Ps < 0.0);
    data->simulationInfo.relations[3] = ($PIdealDiode2$Ps < 0.0);
    data->simulationInfo.relations[4] = ($PIdealDiode4$Ps < 0.0);
    data->simulationInfo.relations[5] = ($PIdealDiode1$Ps < 0.0);
    data->simulationInfo.relations[6] = (time < $PSineVoltage3$PsignalSource$PstartTime);
    data->simulationInfo.relations[7] = (time < $PSineVoltage2$PsignalSource$PstartTime);
    data->simulationInfo.relations[8] = (time < $PSineVoltage1$PsignalSource$PstartTime);
  }
  restore_memory_state(mem_state);
  
  return 0;
}

int checkForDiscreteChanges(DATA *data)
{
  int needToIterate = 0;

  DEBUG(LOG_EVENTS, "check for discrete changes");
  INDENT(LOG_EVENTS);
  if($PIdealDiode1$Poff != $P$PRE$PIdealDiode1$Poff)
  {
    DEBUG2(LOG_EVENTS, "discrete var changed: IdealDiode1._off from %d to %d", $P$PRE$PIdealDiode1$Poff, $PIdealDiode1$Poff);
    needToIterate = 1;
  }
  if($PIdealDiode2$Poff != $P$PRE$PIdealDiode2$Poff)
  {
    DEBUG2(LOG_EVENTS, "discrete var changed: IdealDiode2._off from %d to %d", $P$PRE$PIdealDiode2$Poff, $PIdealDiode2$Poff);
    needToIterate = 1;
  }
  if($PIdealDiode3$Poff != $P$PRE$PIdealDiode3$Poff)
  {
    DEBUG2(LOG_EVENTS, "discrete var changed: IdealDiode3._off from %d to %d", $P$PRE$PIdealDiode3$Poff, $PIdealDiode3$Poff);
    needToIterate = 1;
  }
  if($PIdealDiode4$Poff != $P$PRE$PIdealDiode4$Poff)
  {
    DEBUG2(LOG_EVENTS, "discrete var changed: IdealDiode4._off from %d to %d", $P$PRE$PIdealDiode4$Poff, $PIdealDiode4$Poff);
    needToIterate = 1;
  }
  if($PIdealDiode5$Poff != $P$PRE$PIdealDiode5$Poff)
  {
    DEBUG2(LOG_EVENTS, "discrete var changed: IdealDiode5._off from %d to %d", $P$PRE$PIdealDiode5$Poff, $PIdealDiode5$Poff);
    needToIterate = 1;
  }
  if($PIdealDiode6$Poff != $P$PRE$PIdealDiode6$Poff)
  {
    DEBUG2(LOG_EVENTS, "discrete var changed: IdealDiode6._off from %d to %d", $P$PRE$PIdealDiode6$Poff, $PIdealDiode6$Poff);
    needToIterate = 1;
  }
  RELEASE(LOG_EVENTS);
  
  return needToIterate;
}

/* function to check assert after a step is done */
int checkForAsserts(DATA *data)
{

  
  return 0;
}

/* initial mixed systems */
/* inline mixed systems */
/* parameter mixed systems */
/* model mixed systems */
/* jacobians mixed systems */

/* funtion initialize mixed systems */
void initialMixedSystem(MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* inline mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

int initialAnalyticJacobianG(void* inData)
{
  return 1;
}

static void initialAnalyticJacobianA_0(DATA* data, int index)
{
  int i;
  /* write index for cref: $PInductor2$Pi */
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor2$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PCapacitor2$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor2$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PCapacitor1$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor2$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+2] = $PInductor3$Pi$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor2$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+3] = $PInductor2$Pi$pDERA$indexdiffed;
}

static void initialAnalyticJacobianA_1(DATA* data, int index)
{
  int i;
  /* write index for cref: $PInductor3$Pi */
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor3$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PCapacitor2$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor3$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PCapacitor1$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor3$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+2] = $PInductor3$Pi$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor3$Pi$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+3] = $PInductor2$Pi$pDERA$indexdiffed;
}

static void initialAnalyticJacobianA_2(DATA* data, int index)
{
  int i;
  /* write index for cref: $PCapacitor1$Pv */
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor1$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PCapacitor2$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor1$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PCapacitor1$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor1$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+2] = $PInductor3$Pi$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor1$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+3] = $PInductor2$Pi$pDERA$indexdiffed;
}

static void initialAnalyticJacobianA_3(DATA* data, int index)
{
  int i;
  /* write index for cref: $PCapacitor2$Pv */
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor2$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+0] = $PCapacitor2$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor2$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+1] = $PCapacitor1$Pv$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor2$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+2] = $PInductor3$Pi$pDERA$indexdiffed;
  i = data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor2$Pv$pDERA$indexdiff] - 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.index[i+3] = $PInductor2$Pi$pDERA$indexdiffed;
}


int initialAnalyticJacobianA(void* inData)
{
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  
  int i;
  
  data->simulationInfo.analyticJacobians[index].sizeCols = 4;
  data->simulationInfo.analyticJacobians[index].sizeRows = 4;
  data->simulationInfo.analyticJacobians[index].seedVars = (modelica_real*) calloc(4,sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].resultVars = (modelica_real*) malloc(4*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].tmpVars = (modelica_real*) malloc(0*sizeof(modelica_real));
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex = (unsigned int*) malloc(4*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.index = (unsigned int*) malloc(16*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols = (unsigned int*) malloc(4*sizeof(int));
  data->simulationInfo.analyticJacobians[index].sparsePattern.maxColors = 4;
  data->simulationInfo.analyticJacobians[index].jacobian = NULL;
  
  /* write column ptr of compressed sparse column*/
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor2$Pi$pDERA$indexdiff] = 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PInductor3$Pi$pDERA$indexdiff] = 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor1$Pv$pDERA$indexdiff] = 4;
  data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[$PCapacitor2$Pv$pDERA$indexdiff] = 4;
  for(i=1;i<4;++i)
      data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i] += data->simulationInfo.analyticJacobians[index].sparsePattern.leadindex[i-1];
  
  
  /* call functions to write index for each cref */
  initialAnalyticJacobianA_0(data, index);
  initialAnalyticJacobianA_1(data, index);
  initialAnalyticJacobianA_2(data, index);
  initialAnalyticJacobianA_3(data, index);
  
  /* write color array */
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PInductor2$Pi$pDERA$indexdiff] = 1;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PInductor3$Pi$pDERA$indexdiff] = 2;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PCapacitor1$Pv$pDERA$indexdiff] = 3;
  data->simulationInfo.analyticJacobians[index].sparsePattern.colorCols[$PCapacitor2$Pv$pDERA$indexdiff] = 4;
  
  return 0;
}
int initialAnalyticJacobianB(void* inData)
{
  return 1;
}
int initialAnalyticJacobianC(void* inData)
{
  return 1;
}
int initialAnalyticJacobianD(void* inData)
{
  return 1;
}

int functionJacG_column(void* data)
{
  return 0;
}
int functionJacA_column(void* inData)
{
  state mem_state;
  DATA* data = ((DATA*)inData);
  int index = INDEX_JAC_A;
  mem_state = get_memory_state();
  restore_memory_state(mem_state);
  return 0;
}
int functionJacB_column(void* data)
{
  return 0;
}
int functionJacC_column(void* data)
{
  return 0;
}
int functionJacD_column(void* data)
{
  return 0;
}
int mayer(DATA* data, modelica_real* res){return -1;}
     int lagrange(DATA* data, modelica_real* res){return -1;}
const char *linear_model_frame =
  "model linear_Modelica_Electrical_Analog_Examples_Rectifier\n  parameter Integer n = 4; // states \n  parameter Integer k = 0; // top-level inputs \n  parameter Integer l = 8; // top-level outputs \n"
  "  parameter Real x0[4] = {%s};\n"
  "  parameter Real u0[0] = {%s};\n"
  "  parameter Real A[4,4] = [%s];\n"
  "  parameter Real B[4,0] = zeros(4,0);%s\n"
  "  parameter Real C[8,4] = [%s];\n"
  "  parameter Real D[8,0] = zeros(8,0);%s\n"
  "  Real x[4](start=x0);\n"
  "  input Real u[0];\n"
  "  output Real y[8];\n"
  "\n  Real x_PCapacitor2Pv = x[1];\n  Real x_PCapacitor1Pv = x[2];\n  Real x_PInductor3Pi = x[3];\n  Real x_PInductor2Pi = x[4];\n      Real y_PuAClB1rB = y[1];\n  Real y_PuAClB2rB = y[2];\n  Real y_PuAClB3rB = y[3];\n  Real y_PiAClB1rB = y[4];\n  Real y_PiAClB2rB = y[5];\n  Real y_PiAClB3rB = y[6];\n  Real y_PLosses = y[7];\n  Real y_PuDC = y[8];\n  \n"
  "equation\n  der(x) = A * x + B * u;\n  y = C * x + D * u;\nend linear_Modelica_Electrical_Analog_Examples_Rectifier;\n"
;

#ifdef __cplusplus
}
#endif

/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data);

/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  DATA data;
  setupDataStruc(&data);
  return _main_SimulationRuntime(argc, argv, &data);
}

